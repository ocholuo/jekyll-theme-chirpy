<!DOCTYPE html><html lang="en-US" mode="light" ><head> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="pv-cache-path" content="/true"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Virtulization - Docker Note" /><meta property="og:locale" content="en_US" /><meta name="description" content="[toc]" /><meta property="og:description" content="[toc]" /><link rel="canonical" href="https://ocholuo.github.io//posts/Docker/" /><meta property="og:url" content="https://ocholuo.github.io//posts/Docker/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-11-26T10:11:11-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Virtulization - Docker Note" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"[toc]","headline":"Virtulization - Docker Note","dateModified":"2021-03-22T22:49:31-04:00","url":"https://ocholuo.github.io//posts/Docker/","datePublished":"2020-11-26T10:11:11-05:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/Docker/"},"@context":"https://schema.org"}</script><title>Virtulization - Docker Note | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/rabbit.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2021 Jun 22 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Virtulization - Docker Note</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Virtulization - Docker Note</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 26, 2020, 10:11 AM -0500" prep="on" > Nov 26, 2020 <i class="unloaded">2020-11-26T10:11:11-05:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Mar 22, 2021, 10:49 PM -0400" prefix="Updated " > Mar 22 <i class="unloaded">2021-03-22T22:49:31-04:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="14843 words">82 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><p>[toc]</p><hr /><h1 id="docker-note">Docker Note</h1><hr /><h2 id="basic">basic</h2><ul><li><p>developed with GO launched by Google,</p><li><p>based on <code class="language-plaintext highlighter-rouge">cgroup</code> and <code class="language-plaintext highlighter-rouge">namespace</code> of Linux Kernel and Union FS like AUFS</p><li>a software platform that <font color="red"> packages software (such as applications) into containers </font><ul><li><p>to <font color="blue"> package and isolate the processes </font> which belong to <font color="blue"> Operating system level virtualization technology </font></p><li>Docker is further packaged on a container basis,<ul><li>from ile system, network interconnection to process isolation, etc,<li>isolated processes are independent of the host and other isolated processes.</ul><li> <font color="blue"> greatly simplifying container creation and maintenance </font><p>.</p></ul><li> <font color="red"> Docker is installed on each server that will host containers </font><p>,</p><ul><li>provides simple commands to build, start, or stop containers.<li>quickly deploy and scale applications into any environment.</ul></ul><hr /><h3 id="architecture-in-linux">architecture in linux</h3><p>The initial implementation is based on LXC.</p><ul><li>It removed LXC and use libcontainer instead which is developed by themself since 0.7. Starting with 1.11, it uses runC and containerd further.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/U1jdplX.png" alt="docker-on-linux" /></p><blockquote><p><code class="language-plaintext highlighter-rouge">runc</code> is a Linux command-line tool for creating and running containers according to the OCI container runtime specification.</p></blockquote><blockquote><p><code class="language-plaintext highlighter-rouge">containerd</code> is a daemon that manages container life cycle from downloading and unpacking the container image to container execution and supervision.</p></blockquote><hr /><h2 id="why-use-docker">Why use Docker</h2><p>best used as a solution to:</p><ul><li> <font color="red"> Standardize environments </font><li> <font color="red"> Reduce conflicts between language stacks and versions </font><li> <font color="red"> Use containers as a service </font><li> <font color="red"> Run microservices using standardized code deployments </font><li> <font color="red"> Require portability for data processing </font></ul><p>platform for developers and sysadmins to <font color="red"> build, run, and share applications with containers </font></p><ul><li>The use of containers to deploy applications is called <code class="language-plaintext highlighter-rouge">containerization</code>.</ul><p>containerization</p><ul><li><strong>Flexible</strong>: Even the most complex applications can be containerized.<li><strong>Lightweight</strong>: Containers leverage and share the host kernel, making them much more efficient in terms of system resources than virtual machines.<li><strong>Portable</strong>: build locally, deploy to the cloud, and run anywhere.<li><strong>Loosely coupled</strong>: Containers are highly self sufficient and encapsulated, can replace or upgrade one without disrupting others.<li><strong>Scalable</strong>: You can increase and automatically distribute container replicas across a datacenter.<li><strong>Secure</strong>: Containers apply aggressive constraints and isolations to processes without any configuration required on the part of the user.</ul><hr /><h3 id="images-and-containers">Images and containers</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/ubkaVhF.png" alt="containers" /></p><ul><li><p>Fundamentally, a <strong>container</strong> is nothing but a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers.</p><li><p>container isolation: <font color="red"> each container interacts with its own private filesystem </font></p><li><p>this filesystem is provided by a <strong>Docker image</strong>.</p><ul><li>An image includes everything needed to run an application<li>the code or binary, runtimes, dependencies, and any other filesystem objects required.</ul></ul><hr /><h2 id="containersdocker-vs-traditional-virtualization">Containers/Docker vs Traditional Virtualization.</h2><p>differences between Docker and Traditional Virtualization.</p><ul><li>The <strong>traditional Virtual Machine technology</strong> :<ul><li> <font color="red"> virtualize a set of hardwares to </font><ul><li>run a complete operation system<li>and run the required application process on the system.<li> <font color="red"> runs a full-blown “guest” operating system </font><p>with virtual access to host resources through a hypervisor.</p><li>VMs incur a lot of overhead beyond what is being consumed by your application logic.</ul></ul><li><strong>Container/Docker</strong><ul><li>The application process in the container <font color="red"> runs directly on the host kernel </font><li>the container does not have its own Kernel and hardware virtualiztion.<li>Therefore much lighter than traditional virtual machines.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/XdauvJG.png" alt="virtualization" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/ULoJiCf.png" alt="docker" /></p><h3 id="优势">优势</h3><ol><li>更高效的利用系统资源<ul><li>a method of operating system virtualization<ul><li>容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<li>Docker 对系统资源的利用率更高。<li>runs natively on Linux and <font color="red"> shares the kernel of the host machine with other containers </font><li>runs a discrete process, taking no more memory than any other executable, making it lightweight.</ul><li> <font color="red"> run an application and its dependencies </font><p>in <font color="red"> resource-isolated processes </font></p><ul><li>无论是 应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。<li>因此，一个相同配置的主机，往往可以运行更多数量的 Docker 应用。</ul></ul><li>更快速的启动时间 Faster Startup Time<ul><li>传统的虚拟机技术启动应用服务往往需要数分钟，<li>Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。<li>节约了开发、测试、部署的时间。</ul><li>一致的运行环境 <font color="red"> Consistent Operating Environment </font><ul><li>because everything are packaged into a single object.<li>开发过程中一个常见的问题是环境一致性问题。开发环境、测试环境、生产环境不一致，导致bug未在开发过程中被发现。<li>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性<ul><li>不会再出现 「这段代码在我机器上没问题啊」 这类问题。</ul><li>Containers hold everything that the software needs to run,<ul><li>such as libraries, system tools, application’s code, configurations, dependencies, and the runtime.</ul><li>ensure <font color="blue"> quick, reliable, and consistent deployments </font>. regardless of deployment environment.</ul><li>持续交付和部署 CI/CD<ul><li>对开发和运维(DevOps)人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<li>create and configure once to run anywhere.<li>使用 Docker 可以通过定制<code class="language-plaintext highlighter-rouge">应用镜像 application mirrors with Docker</code>来实现持续集成、持续交付、部署。<li><strong>Developers</strong>: <strong>build images with Dockerfile</strong> and use <code class="language-plaintext highlighter-rouge">Continuous Integration for integration testing</code>.<li><strong>Operation teams</strong>: <strong>deploy production environments quickly with the images</strong>, and even <strong>make automatic deployments</strong> possible by using <code class="language-plaintext highlighter-rouge">Continuous Delivery/Deployment techniques</code>.<li>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应 用运行所需条件，帮助更好的生产环境中部署该镜像。</ul><li>更轻松的迁移 Easier migration<ul><li>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。<li>Docker 可以在很多平台上运行，无 论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。<li>因此用户可以很轻易的将在一个 平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</ul><li>更轻松的维护和扩展<ul><li>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。<li>Docker 团队同各个开源项目团队一起维护了高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大降低了应用服务的镜像 制作成本。</ul></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/eZtGmjR.png" alt="Screen Shot 2020-11-28 at 13.18.53" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/NOjFPJV.png" alt="Screen Shot 2020-11-25 at 01.57.58" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/hC6oigX.png" alt="Screen Shot 2020-05-06 at 20.38.20" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/4LDPQK7.png" alt="Screen Shot 2020-07-27 at 09.38.41" /></p><hr /><h2 id="使用">使用</h2><p>基本概念 Docker 包括三个基本概念</p><ul><li>镜像( Image )<li>容器( Container )<li>仓库( Repository )</ul><hr /><h3 id="docker-image-镜像"><code class="language-plaintext highlighter-rouge">Docker Image</code> 镜像</h3><p>操作系统分为 <font color="blue"> 内核 </font> 和 <font color="blue"> 用户空间 </font></p><ul><li>对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提 供用户空间支持。<ul><li>Docker Image，就相当于是一个 root 文件系统。<li>比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</ul><li>Docker Image<ul><li>是一个特殊的文件系统<li>除了提供容器运行时所需的程序、库、资源、配置等文件外<li>还包含了一 些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。</ul><li>镜像不包含任何动态数据，其内容在构建之 后也不会被改变。</ul><h4 id="分层存储-advanced-multi-layered-unification-filesystem-aufs">分层存储 Advanced Multi-layered Unification Filesystem (AUFS)</h4><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的</p><ul><li>因此在 Docker 设计时，就充分利用 <code class="language-plaintext highlighter-rouge">Union FS</code> 的技术，将其设计为分层存储的架构。<li>所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联 合组成。<li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只 发生在自己这一层。<ul><li>比如，<li>删除前一层文件的操作，<li>实际不是真的删除前一层的文件，<li>而是仅在当前层标记为该 文件已删除。<li>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</ul><li>因此，在构 建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前 清理掉。<li>分层存储的特征还使得镜像的复用、定制变的更为容易。<li>甚至可以用之前构建好的镜像作为基础层，然后进一步 添加新的层，以定制自己所需的内容，构建新的镜像。</ul><hr /><h3 id="docker-container-容器"><code class="language-plaintext highlighter-rouge">Docker Container</code> 容器</h3><ul><li>镜像( Image )和容器( Container )的关系，就像是面向对象程序设计中的 类 和 实例 一样<li>镜像是静态的定义，<li>容器是镜像运行时的实体。<ul><li>容器可以被创建、启动、停止、删除、暂停等。<li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。</ul><li>因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。<li>容器内的进程 是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。<li>这种特性使得容器封装 的应用比直接在宿主运行更加安全。<ul><li>因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</ul><li><code class="language-plaintext highlighter-rouge">multi-layered filesystem</code> is applied to <strong>images</strong>, and so as the <strong>containers</strong>.<ul><li>When a container is running, it is based on its image, with a writable layer created on top of it.<li>We call this layer prepared for R/W at runtime <code class="language-plaintext highlighter-rouge">Container Layer</code><li><code class="language-plaintext highlighter-rouge">容器存储层</code>的生存周期和容器一样<ul><li>容器消亡时，容器存储层也随之消亡。<li>因此任何保存于容器存储层的信息 都会随容器删除而丢失。</ul></ul></ul><hr /><h4 id="docker-container-的读写"><code class="language-plaintext highlighter-rouge">Docker Container</code> 的读写</h4><blockquote><p>recommended by the Docker Development Best Practices</p></blockquote><p><strong>should not write any data to the <code class="language-plaintext highlighter-rouge">container layer</code></strong></p><ul><li>make it stateless.<li>All file write operations should adhere to <code class="language-plaintext highlighter-rouge">Volume</code> or <code class="language-plaintext highlighter-rouge">bind mounts</code>.<li><code class="language-plaintext highlighter-rouge">Writing to volume or bind mounts</code> skips the container layer and <code class="language-plaintext highlighter-rouge">R/W to host storage(or network storage) directly</code><ul><li>achieves better performance and stability.</ul><li>数据卷的生存周期独立于容器<ul><li>容器消亡，数据卷不会消亡。<li>因此使用数据卷后，容器删除或者重新运行之 后，数据却不会丢失。</ul></ul><blockquote><p>容器 = 镜像 + 读写层。并且容器的定义并没有提及是否要运行容器。 running container: 一个可读写的 统一文件系统 加上隔离的进程空间 和包含其中的进程</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/7SQmtvm.png" alt="dacd660134e97cca60e04ba5fdcfa79e" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/YqqmTqZ.png" alt="3b9079593f15903497a37c64a23b9c39" /></p><p>正是文件系统隔离技术使得Docker成为了一个前途无量的技术。</p><ul><li>一个容器中的进程可能会对文件进行修改、删除、创建，<li>这些改变都将作用于可读写层（read-write layer）。</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/IG7bHa3.png" alt="1ccc2aa9e11e25e5ed2efd18cf1052c4" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/J9MUw7z.png" alt="a20b70e3e4ca61faa2c3436e1bb2d93a" /></p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 可以通过运行以下命令来验证:</span>
docker run ubuntu <span class="nb">touch </span>happiness.txt

<span class="c"># 即便是这个ubuntu容器不再运行，我们依旧能够在主机的文件系统上找到这个新文件。</span>
find / <span class="nt">-name</span> happiness.txt
/var/lib/docker/aufs/diff/860a7b...889/happiness.txt
</pre></table></code></div></div><h4 id="image-layer-definition">Image Layer Definition</h4><p>为了将零星的数据整合起来，提出了镜像层（image layer）这个概念。</p><ul><li>一个层并不仅仅包含文件系统的改变，它还能包含了其他重要信息。<li>元数据（metadata）就是关于这个层的额外信息，它不仅能够让Docker获取运行和构建时的信息，还包括父层的层次信息。<li>需要注意，只读层和读写层都包含元数据。</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/EDcKDa7.png" alt="f3218a8fcdd1fd8bcd5a719ca3c64f59" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/wxnZ8cb.png" alt="39fb0f8e630b338bcca7a29da3acabb7" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/QCmf8xH.png" alt="53e377deeeb5f30bf939ed0836f851c9" /></p><h3 id="docker-commands">docker commands</h3><div class="table-wrapper"><table><thead><tr><th>cmd<th>pic<tbody><tr><td><code class="language-plaintext highlighter-rouge">docker pull ubuntu:18.04</code><td>download<tr><td><code class="language-plaintext highlighter-rouge">docker run &lt;image-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/XKic8PI.jpg" alt="01aedf55bd21abbe607b3864d76f0ec0" /><tr><td><code class="language-plaintext highlighter-rouge">docker create &lt;image-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/J82Sli2.jpg" alt="062e7af0929dd205b2ac6efdd937d6f4" /><tr><td><code class="language-plaintext highlighter-rouge">docker start &lt;container-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/AGAzgEq.jpg" alt="1c38d4735e9760bdca025ff50a1b5386" /> <br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/wq40mMI.jpg" alt="275cc486d4ce7ecbdecf0ecc1de0a34b" /><tr><td><code class="language-plaintext highlighter-rouge">docker ps</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/4U1HNNz.jpg" alt="f05a2a8dfc6641d8237306ff575aa283" /><tr><td><code class="language-plaintext highlighter-rouge">docker ps –a</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/7uFxaWP.jpg" alt="d7f7b0ada7fc1c641c90745a959f9c05" /><tr><td><code class="language-plaintext highlighter-rouge">docker images</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/Ede9USJ.jpg" alt="d5b0b3e2e7acdcf35e7577d7670a46f7" /><tr><td><code class="language-plaintext highlighter-rouge">docker images -a</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/86wPwgT.jpg" alt="ce083575e95a0e46b105c3596c12ca71" /><tr><td><code class="language-plaintext highlighter-rouge">docker stop &lt;container-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/H0GEqJf.jpg" alt="a41de8fe542efe25e3620691ad9238df" /><tr><td><code class="language-plaintext highlighter-rouge">docker kill &lt;container-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/F9zAAgG.jpg" alt="ac1cbc31d4f191e26e05fb1a11f04d26" /><tr><td><code class="language-plaintext highlighter-rouge">docker pause &lt;container-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/12MQZ0E.jpg" alt="b701a3c51e7d1915da3bea0bc43efcd1" /><tr><td><code class="language-plaintext highlighter-rouge">docker rm &lt;container-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/VvbXmHc.jpg" alt="8fa2d6e19c29f18548624efd64eb6dfa" /> <br /> docker rm命令会移除构成容器的可读写层。注意，这个命令只能对非运行态容器执行。<tr><td><code class="language-plaintext highlighter-rouge">docker rmi &lt;image-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/5DgiDu6.jpg" alt="32a7f413a5f8ff936dd0f4a31d25fdcc" /> <br /> docker rmi 命令会移除构成镜像的一个只读层。<br /> 只能够使用docker rmi来移除最顶层（top level layer）（也可以说是镜像）<br /> 也可以使用-f参数来强制删除中间的只读层。<tr><td><code class="language-plaintext highlighter-rouge">docker commit &lt;container-id&gt; [REPOSITORY[:TAG]]</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/NsvFAtt.jpg" alt="3c02ccf4e7a2a353af065d93b26ae89e" /> <br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/DYct48G.jpg" alt="28059b3a499faba896263c0ff077fe3a" /> <br /> 将容器的可读写层转换为一个只读层，把一个容器转换成了不可变的镜像。<tr><td><code class="language-plaintext highlighter-rouge">docker build -t makali:v1</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/zOlePPX.jpg" alt="b22cd304f28c715ae3ae6812476b222d" /> <br /><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/fBRTJCc.png" alt="100712263ecf4544dd11602adc39ee3e" /> <br /> build命令根据Dockerfile文件中的FROM指令获取到镜像，然后重复地 <br /> 1）run（create和start）<br /> 2）修改 <br /> 3）commit。<br /> 在循环中的每一步都会生成一个新的层，因此许多新的层会被创建。<tr><td><code class="language-plaintext highlighter-rouge">docker exec &lt;running-container-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/ac6qMxt.jpg" alt="db64b3b38aff136d42e9ffeb81675bda" /><tr><td><code class="language-plaintext highlighter-rouge">docker inspect &lt;container-id&gt; or &lt;image-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/5AWZAer.jpg" alt="184f9d55770ca036cb5b1e6d96ce4a12" /> <br /> docker inspect命令会提取出容器或者镜像最顶层的元数据。<tr><td><code class="language-plaintext highlighter-rouge">docker save &lt;image-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/MNiSruI.jpg" alt="70cdbaf975c88bc83423d88be85476b5" /> <br /> 创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令为每一个层都保存了它们的元数据。这个命令只能对镜像生效。<tr><td><code class="language-plaintext highlighter-rouge">docker export &lt;container-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/lsayIKA.jpg" alt="1714c3dd524c807bf9c9b4d0fbe4d056" /> <br /> 创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容 <br /> expoxt后的容器再import到Docker中，通过docker images –tree命令只能看到一个镜像；<br /> save后的镜像能够看到这个镜像的历史镜像<tr><td><code class="language-plaintext highlighter-rouge">docker history &lt;image-id&gt;</code><td><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/Tc2gUar.jpg" alt="b513dd5467f23fdd23523f60242d5dcb" /> <br /> docker history命令递归地输出指定镜像的历史镜像。</table></div><hr /><h3 id="docker-registry-仓库"><code class="language-plaintext highlighter-rouge">Docker Registry</code> 仓库</h3><p>After the construction of an image, we can easily run it on a host.</p><ul><li>but, to use the image on other servers, need a centralized image storage and distribution service, <strong>Docker Registry</strong>.<li>一个 Docker Registry 中可以包含多个 <code class="language-plaintext highlighter-rouge">仓库( Repository )</code>;<li>每个仓库可以包含多个 <code class="language-plaintext highlighter-rouge">标签( Tag )</code>;<li>每个标签对应一个<code class="language-plaintext highlighter-rouge">镜像</code>。<ul><li>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。<li>通过 <code class="language-plaintext highlighter-rouge">&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。<li>如果不给出标签，将以 <code class="language-plaintext highlighter-rouge">latest</code> 作为 默认标签。</ul></ul><p>以 Ubuntu 镜像 为例，</p><ul><li>ubuntu 是仓库的名字，其内包含有不同的版本标签，如， 16.04 , 18.04 。<li>我们可以通过 ubuntu:16.04 ，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。<li>如果忽略了标 签，比如 ubuntu ，那将视为 ubuntu:latest 。</ul><p>仓库名经常以 两段式路径 形式出现，</p><ul><li>比如 jwilder/nginx-proxy ，前者往往意味着 Docker Registry 多 用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软 件或服务。</ul><h4 id="docker-registry-公开服务">Docker Registry 公开服务</h4><ul><li>开放给用户使用、允许用户管理镜像的 Registry 服务。<li>一般这类公开服务允许用户 免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。<li>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜 像。<li>除此以外，还有 Red Hat 的 Quay.io;Google 的 Google Container Registry，Kubernetes 的镜像使用 的就是这个服务。</ul><h4 id="私有-docker-registry">私有 Docker Registry</h4><ul><li>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。<li>Docker 官方提供了 Docker Registry 镜 像，可以直接使用做为私有 Registry 服务。</ul><hr /><h2 id="安装-docker">安装 Docker</h2><p>Docker 分为 stable test 和 nightly 三个更新频道。</p><hr /><h3 id="macos-安装">macOS 安装</h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre>Docker 系统要求
<span class="c"># Docker Desktop for Mac 要求系统最低为 macOS Catalina 10.13。</span>

安装
<span class="c"># 使用 Homebrew 安装</span>
<span class="nv">$ </span>brew cask <span class="nb">install </span>docker

<span class="c"># 手动下载安装</span>
<span class="c"># 如果需要手动下载，请点击以下链接下载 Stable 或 Edge 版本的 Docker Desktop for Mac。</span>
<span class="c"># 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖 拽到 Application 文件夹即可(其间需要输入用户密码)。</span>


<span class="c"># 启动终端后，通过命令可以检查安装后的 Docker 版本。</span>
<span class="nv">$ </span>docker <span class="nt">--version</span>
Docker version 19.03.8, build afacb8b

<span class="nv">$ </span>docker-compose <span class="nt">--version</span>
docker-compose version 1.25.5, build 8a1c60f6

<span class="c"># The docker setup does not work as in a normal Linux machine, on a Mac it is much more complicated. But it can be done!</span>

brew cask <span class="nb">install </span>docker virtualbox
brew <span class="nb">install </span>docker-machine
docker-machine create <span class="nt">--driver</span> virtualbox default
docker-machine restart
<span class="nb">eval</span> <span class="s2">"</span><span class="si">$(</span>docker-machine <span class="nb">env </span>default<span class="si">)</span><span class="s2">"</span> <span class="c"># This might throw an TSI connection error. In that case run docker-machine regenerate-certs default</span>
<span class="o">(</span>docker-machine restart<span class="o">)</span> <span class="c"># maybe needed</span>
docker run hello-world
</pre></table></code></div></div><p>test:</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c"># 1. 运行一个 Nginx 服务器:</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 80:80 <span class="nt">--name</span> webserver nginx
<span class="c"># 服务运行后，可以访问 http://localhost，如果看到了 "Welcome to nginx!"，就说明 Docker Desktop for Mac 安装成功了。</span>
<span class="c"># 要停止 Nginx 服务器并删除执行下面的命令:</span>
<span class="nv">$ </span>docker stop webserver
<span class="nv">$ </span>docker <span class="nb">rm </span>webserver



<span class="c"># 2. running the hello-world Docker image:</span>

<span class="nv">$ </span>docker run hello-world

    Unable to find image <span class="s1">'hello-world:latest'</span> locally
    latest: Pulling from library/hello-world
    ca4f61b1923c: Pull <span class="nb">complete
    </span>Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7
    Status: Downloaded newer image <span class="k">for </span>hello-world:latest

    Hello from Docker!
    This message shows that your installation appears to be working correctly.
    ...

<span class="c"># Run docker image ls to list the hello-world image that you downloaded to your machine.</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span>

<span class="c"># List the hello-world container (spawned by the image) which exits after displaying its message. If it is still running, you do not need the --all option:</span>
    <span class="nv">$ </span>docker ps <span class="nt">--all</span>

    CONTAINER ID     IMAGE           COMMAND      CREATED            STATUS
    54f4984ed6a8     hello-world     <span class="s2">"/hello"</span>     20 seconds ago     Exited <span class="o">(</span>0<span class="o">)</span> 19 seconds ago

</pre></table></code></div></div><hr /><h2 id="docker-image-command"><code class="language-plaintext highlighter-rouge">docker image</code> command</h2><ul><li>镜像是 Docker 的三大组件之一。<li>Docker 运行容器前需要本地存在对应的镜像<li>如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</ul><hr /><h3 id="docker-pull-ubuntu1804获取镜像"><code class="language-plaintext highlighter-rouge">docker pull ubuntu:18.04</code>获取镜像</h3><p><code class="language-plaintext highlighter-rouge">docker pull</code></p><ul><li>Docker Hub 上有大量的高质量的镜像可以用，<li>从 Docker Image 仓库获取镜像</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre>docker pull <span class="o">[</span>选项] <span class="o">[</span>Docker Registry 地址[:端口号]/]仓库名[:标签]
<span class="c"># - Docker Image 仓库地址: 一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 Docker Hub(docker.io)。</span>
<span class="c"># - 仓库名: 两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。</span>
<span class="c"># - 对于 Docker Hub，如果 不给出用户名，则默认为 library 官方镜像。</span>

<span class="c"># 比如:</span>

<span class="nv">$ </span>docker pull kalilinux/kali-rolling

<span class="nv">$ </span>docker pull ubuntu:18.04
<span class="c"># 18.04: Pulling from library/ubuntu</span>
<span class="c"># bf5d46315322: Pull complete</span>
<span class="c"># 9f13e0ac480c: Pull complete</span>
<span class="c"># e8988b5b3097: Pull complete</span>
<span class="c"># 40af181810e7: Pull complete</span>
<span class="c"># e6f7c7e5c03e: Pull complete</span>
<span class="c"># Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe Status: Downloaded newer image for ubuntu:18.04</span>

<span class="c"># 上面的命令中没有给出 Docker Image 仓库地址，因此将会从 Docker Hub 获取镜像。</span>
<span class="c"># 镜像名称是 ubuntu:18.04 ，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。</span>

<span class="c"># 从下载过程中可以分层存储，镜像是由多层存储所构成。</span>
<span class="c"># 下载也是一层层的去下载， 并非单一文件。</span>
<span class="c"># 下载过程中给出了每一层的 ID 的前 12 位。</span>
<span class="c"># 并且下载结束后，给出该镜像完整的 sha256 的 摘要，以确保下载一致性。</span>
</pre></table></code></div></div><hr /><h3 id="docker-run--it---rm-ubuntu1804-bash-运行"><code class="language-plaintext highlighter-rouge">docker run -it --rm ubuntu:18.04 bash</code> 运行</h3><ul><li>以镜像为基础启动并运行一个容器。<ul><li>-i :交互式操作<li>-t : 进入 bash 执行一些命令并查看返回结果，需要交互式终端。<li>–rm: 容器退出后随之将其删除。<ul><li>默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。<li>不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</ul></ul></ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c"># 以上面的 ubuntu:18.04 为例，启动里面的 bash 并且进行交互式操作:</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> ubuntu:18.04 bash

root@e7009c6ce357:/# <span class="nb">cat</span> /etc/os-release <span class="nv">NAME</span><span class="o">=</span><span class="s2">"Ubuntu"</span>
<span class="nv">VERSION</span><span class="o">=</span><span class="s2">"18.04.1 LTS (Bionic Beaver)"</span> <span class="nv">ID</span><span class="o">=</span>ubuntu
<span class="nv">ID_LIKE</span><span class="o">=</span>debian
<span class="nv">PRETTY_NAME</span><span class="o">=</span><span class="s2">"Ubuntu 18.04.1 LTS"</span>
<span class="nv">VERSION_ID</span><span class="o">=</span><span class="s2">"18.04"</span>
<span class="nv">HOME_URL</span><span class="o">=</span><span class="s2">"https://www.ubuntu.com/"</span>
<span class="nv">SUPPORT_URL</span><span class="o">=</span><span class="s2">"https://help.ubuntu.com/"</span> <span class="nv">BUG_REPORT_URL</span><span class="o">=</span><span class="s2">"https://bugs.launchpad.net/ubuntu/"</span> <span class="nv">PRIVACY_POLICY_URL</span><span class="o">=</span><span class="s2">"https://www.ubuntu.com/legal/terms-and-policies/privacy-pol icy"</span>
<span class="nv">VERSION_CODENAME</span><span class="o">=</span>bionic
<span class="nv">UBUNTU_CODENAME</span><span class="o">=</span>bionic

<span class="c"># docker run: 运行容器的命令</span>
<span class="c"># -i :交互式操作</span>
<span class="c"># -t 终端。进入 bash 执 行一些命令并查看返回结果，因此我们需要交互式终端。</span>
<span class="c"># --rm: 容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。</span>
<span class="c"># ubuntu:18.04 :这是指用 ubuntu:18.04 镜像为基础来启动容器。</span>
<span class="c"># bash: 放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash 。</span>
<span class="c"># 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。</span>
<span class="c"># 通过 exit 退出了这个容器。</span>
</pre></table></code></div></div><hr /><h3 id="docker-image-ls-列出镜像"><code class="language-plaintext highlighter-rouge">docker image ls</code> 列出镜像</h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c"># 列出已经下载下来的镜像</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span>
<span class="c"># 仓库名              标签、               镜像 ID、           创建时间              所占用的空间</span>
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        5 days ago          183 MB
nginx                latest              05a60462f8ba        5 days ago          181 MB
mongo                3.2                 fe9198c04d62        5 days ago          342 MB
&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB  <span class="c"># 虚悬镜像 dangling image</span>
ubuntu               18.04               f753707788c5        4 weeks ago         127 MB
ubuntu               latest              f753707788c5        4 weeks ago         127 MB

<span class="c"># 镜像 ID 则是镜像的唯一标识</span>
<span class="c"># 一个镜像可以对应多个 标签。</span>
</pre></table></code></div></div><h3 id="docker-system-df-镜像体积"><code class="language-plaintext highlighter-rouge">docker system df</code> 镜像体积</h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c"># 镜像体积所占用空间和在 Docker Hub 上看到的镜像大小不同。</span>
<span class="c"># - ubuntu:18.04 镜像大小，在这里是 127 MB ，</span>
<span class="c"># - 但是在 Docker Hub 显示的却是 50 MB 。</span>
<span class="c"># - 这是因为 Docker Hub 中显示的体积是压缩后的体积。</span>
<span class="c"># - 在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。</span>
<span class="c"># - 而 docker image ls 显示的是镜像下载到本地后，展开的大小(展开后的各层所占空间的总和)，因为镜像到本地后，查看空间的时候，更关心的是本地磁 盘空间占用的大小。</span>

<span class="c"># docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。</span>
<span class="c"># - 由 于 Docker Image 是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥 有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要 比这个列表镜像大小的总和要小的多。</span>

<span class="c"># 便捷的查看镜像、容器、数据卷所占用的空间。</span>
<span class="nv">$ </span>docker system <span class="nb">df
</span>TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              24                  0                   1.992GB             1.992GB <span class="o">(</span>100%<span class="o">)</span>
Containers          1                   0                   62.82MB             62.82MB <span class="o">(</span>100%<span class="o">)</span>
Local Volumes       9                   0                   652.2MB             652.2MB <span class="o">(</span>100%<span class="o">)</span>
Build Cache                                                 0B                  0B
</pre></table></code></div></div><h3 id="docker-image-ls--f-danglingtrue-虚悬镜像"><code class="language-plaintext highlighter-rouge">docker image ls -f dangling=true</code> 虚悬镜像</h3><p>虚悬镜像(dangling image)</p><ul><li>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。</none><li>无标签镜像</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c"># 既没有仓库名，也没有标签，均为 &lt;none&gt;</span>
<span class="c"># 仓库名              标签、               镜像 ID、           创建时间              所占用的空间</span>
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        5 days ago          183 MB
&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB  <span class="c"># 虚悬镜像 dangling image</span>

<span class="c"># docker pull</span>
<span class="c"># 镜像 mongo:3.2, 随着新版本后，重新 docker pull mongo:3.2 时， mongo:3.2 这个镜像名被转移到了新下载的镜像身上</span>
<span class="c"># 旧的镜像上的这个名称则被取消，从而成为了 &lt;none&gt; 。</span>
<span class="c"># docker build</span>


<span class="c"># 专门显示 这类镜像:</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">-f</span> <span class="nv">dangling</span><span class="o">=</span><span class="nb">true
</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB

<span class="c"># 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的:</span>
<span class="nv">$ </span>docker image prune
</pre></table></code></div></div><h4 id="docker-image-ls--a-中间层镜像"><code class="language-plaintext highlighter-rouge">docker image ls -a</code> 中间层镜像</h4><ul><li>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。<li>在使用一段时间后，可能会看到一些依赖 的中间层镜像。<li>默认的 docker image ls 只会显示顶层镜像</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># 显示包括中间层镜像在内的列出镜像所有镜像的话，加 -a 参数。</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">-a</span>
<span class="c"># 这样会看到很多无标签的镜像</span>
<span class="c"># 与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。</span>

<span class="c"># 这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。</span>
<span class="c"># 也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。</span>
<span class="c"># 只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</span>
</pre></table></code></div></div><h3 id="docker-image-ls-xxx--列出部分镜像"><code class="language-plaintext highlighter-rouge">docker image ls xxx </code> 列出部分镜像</h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c"># 不加任何参数的情况下， docker image ls 会列出所有顶层镜像，</span>
<span class="c"># 只希望列出部分镜像。 docker image ls 有好几个参数可以帮助做到这个事情。</span>

<span class="c"># 根据仓库名列出镜像</span>
<span class="nv">$ </span>docker image <span class="nb">ls </span>ubuntu
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.04               f753707788c5        4 weeks ago         127 MB
ubuntu              latest              f753707788c5        4 weeks ago         127 MB


<span class="c"># 列出特定的某个镜像，也就是说指定仓库名和标签</span>
<span class="nv">$ </span>docker image <span class="nb">ls </span>ubuntu:18.04
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.04               f753707788c5        4 weeks ago         127 MB


<span class="c"># 除此以外， docker image ls 还支持强大的过滤器参数 --filter ，或者简写 -f 。</span>
<span class="c"># 使用过滤器来列出虚悬镜像</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">-f</span> <span class="nv">dangling</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 希望看到在 mongo:3.2 之后建 立的镜像，可以用下面的命令:</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">-f</span> <span class="nv">since</span><span class="o">=</span>mongo:3.2
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
redis               latest              5f515359c7f8        5 days ago          183 MB
nginx               latest              05a60462f8ba        5 days ago          181 MB
<span class="c"># 想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">-f</span> <span class="nv">before</span><span class="o">=</span>mongo:3.2
<span class="c"># 此外，如果镜像构建时，定义了 LABEL ，还可以通过 LABEL 来过滤。</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">-f</span> <span class="nv">label</span><span class="o">=</span>com.example.version<span class="o">=</span>0.1
</pre></table></code></div></div><h4 id="以特定格式显示">以特定格式显示</h4><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c"># 默认情况下， docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。</span>
<span class="c"># 比 如，刚才删除虚悬镜像的时候，需要利用 docker image ls 把虚悬镜像的 ID 列来，然后交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">-q</span>
5f515359c7f8
05a60462f8ba
fe9198c04d62
00285df0df87
f753707788c5
f753707788c5
1e0c3dd64ccd

<span class="c"># --filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这 组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命 令中看到这类搭配以完成很强大的功能。</span>


<span class="c"># 只是对表格的结构不满意，希望自己组织列; 或者不希望有标题, 这就用到了 Go 的模板语法。</span>

<span class="c"># 直接列出镜像结果，并且只包含镜像ID和仓库名:</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">--format</span> <span class="s2">": "</span>
5f515359c7f8: redis
05a60462f8ba: nginx
fe9198c04d62: mongo
00285df0df87: &lt;none&gt;
f753707788c5: ubuntu
f753707788c5: ubuntu
1e0c3dd64ccd: ubuntu


<span class="c"># 或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列:</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">--format</span> <span class="s2">"table </span><span class="se">\t\t</span><span class="s2">"</span>
IMAGE ID            REPOSITORY          TAG
5f515359c7f8        redis               latest
05a60462f8ba        nginx               latest
fe9198c04d62        mongo               3.2
00285df0df87        &lt;none&gt;              &lt;none&gt;
f753707788c5        ubuntu              18.04
f753707788c5        ubuntu              latest
</pre></table></code></div></div><hr /><h3 id="docker-image-rm-centoslatest-删除"><code class="language-plaintext highlighter-rouge">docker image rm centos:latest</code> 删除</h3><p>删除本地的镜</p><ul><li>用 ID、镜像名、摘要删除镜像<li>可以是 镜像短ID 、 镜像长ID 、 镜像名 或者 镜像摘要 。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="nv">$ </span>docker image <span class="nb">rm</span> <span class="o">[</span>选项] &lt;镜像1&gt; <span class="o">[</span>&lt;镜像2&gt; ...]

<span class="nv">$ </span>docker image <span class="nb">ls
</span>REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB
redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB
docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB
nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB

<span class="c"># 用短 ID 来删除镜像。</span>
<span class="c"># docker image ls 默认已经是短 ID 了</span>
<span class="c"># 一 般取前3个字符以上就可以了。</span>
<span class="nv">$ </span>docker image <span class="nb">rm </span>501

<span class="c"># 用 镜像名 ，&lt;仓库名&gt;:&lt;标签&gt;</span>
<span class="nv">$ </span>docker image <span class="nb">rm </span>centos:latest

<span class="c"># 用 镜像摘要 删除镜像。</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span> <span class="nt">--digests</span>
REPOSITORY   TAG       DIGEST                                                                    IMAGE ID            CREATED             SIZE
node         slim      sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB

<span class="nv">$ </span>docker image <span class="nb">rm </span>node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
</pre></table></code></div></div><h4 id="untagged-和-deleted">Untagged 和 Deleted</h4><p>删除行为分为两类，一类是 <code class="language-plaintext highlighter-rouge">Untagged</code> ，另一类 是 <code class="language-plaintext highlighter-rouge">Deleted</code> 。</p><ul><li>镜像的唯一标识是其 <code class="language-plaintext highlighter-rouge">ID</code> 和 <code class="language-plaintext highlighter-rouge">摘要</code><li>一个镜像可以有多个标签。<li>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。<ul><li>将满足我 们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。<li>因为一个镜像可以对应多个标签，当还有别的标签指向了这个镜像，那么 Delete 行为 就不会发生。</ul><li>所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。<li>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。<li>镜像是多层存储结 构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。<li>镜像的多层结构让镜像复用变得非常容易， 因此很有可能某个其它镜像正依赖于当前镜像的某一层。<li>这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。<li>这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个 镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不 一样的原因。<li>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在(即使容器没有运 行)，那么同样不可以删除这个镜像。<li>容器是以镜像为基础，再加一层容器存储层，组成这样的多层 存储结构去运行的。<li>因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。<li>如果这些容器是不需要 的，应该先将它们删除，然后再来删除镜像。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 用 docker image ls 命令来配合像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用docker image rm ，这样可以成批的删除希望删除的镜像。</span>
<span class="c"># 删除所有仓库名为 redis 的镜像:</span>
<span class="nv">$ </span>docker image <span class="nb">rm</span> <span class="si">$(</span>docker image <span class="nb">ls</span> <span class="nt">-q</span> redis<span class="si">)</span>
<span class="c"># 或者删除所有在 mongo:3.2 之前的镜像:</span>
<span class="nv">$ </span>docker image <span class="nb">rm</span> <span class="si">$(</span>docker image <span class="nb">ls</span> <span class="nt">-q</span> <span class="nt">-f</span> <span class="nv">before</span><span class="o">=</span>mongo:3.2<span class="si">)</span>
</pre></table></code></div></div><hr /><h2 id="commit-理解镜像构成">commit 理解镜像构成</h2><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>
首先使用 docker ps <span class="nt">-l</span>命令获得安装完ping命令之后容器的id。然后把这个镜像保存为learn/ping。

提示：
1. 运行docker commit，可以查看该命令的参数列表。

2. 你需要指定要提交保存容器的ID。<span class="o">(</span>译者按：通过docker ps <span class="nt">-l</span> 命令获得<span class="o">)</span>

3. 无需拷贝完整的id，通常来讲最开始的三至四个字母即可区分。（译者按：非常类似git里面的版本号<span class="o">)</span>

<span class="c"># 正确的命令：</span>
<span class="nv">$ </span>docker commit 698 learn/ping
</pre></table></code></div></div><hr /><h2 id="docker-command"><code class="language-plaintext highlighter-rouge">docker</code> command</h2><ul><li>容器是独立运行的<code class="language-plaintext highlighter-rouge">一个或一组应用</code>，以及它们的<code class="language-plaintext highlighter-rouge">运行态环境</code>。<li>对应的，虚拟机可以理解为<code class="language-plaintext highlighter-rouge">模拟运行的一整套操作系统</code>(提供了运行态环境和其他系统环境)和<code class="language-plaintext highlighter-rouge">跑在上面的应用</code>。</ul><h3 id="启动容器-docker-run-ubuntu1804">启动容器 <code class="language-plaintext highlighter-rouge">docker run ubuntu:18.04</code></h3><p>启动容器有两种方式</p><ul><li>基于镜像新建一个容器并启动，<li>将在终止状态( stopped )的容器重新启动。</ul><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括:</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载<li>利用镜像创建并启动一个容器<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<li>从地址池配置一个 ip 地址给容器<li>执行用户指定的应用程序<li>执行完毕后容器被终止</ul><blockquote><p>因为 Docker 的容器实在太轻量级了，很多时候都是随时删除和新创建容器。</p></blockquote><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c"># 新建并启动</span>
<span class="c"># 输出一个 “Hello World”，之后终止容器。</span>
<span class="nv">$ </span>docker run ubuntu:18.04 /bin/echo <span class="s1">'Hello world'</span>
Hello world
<span class="c"># 这跟在本地直接执行 /bin/echo 'hello world' 几乎感觉不出任何区别。</span>


<span class="c"># 启动一个 bash 终端，允许用户进行交互。</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> ubuntu:18.04 /bin/bash
root@af8bae53bdd3:/#
root@af8bae53bdd3:/# <span class="nb">ls
</span>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
<span class="c"># -t 选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上</span>
<span class="c"># -i 则让容器的标准输入保持打开。</span>
<span class="c"># 在交互模式下，用户可以通过所创建的终端来输入命令</span>


<span class="c"># 列出本机正在运行的容器</span>
<span class="nv">$ </span>docker container <span class="nb">ls</span>

<span class="c"># 列出本机所有容器，包括终止运行的容器</span>
<span class="nv">$ </span>docker container <span class="nb">ls</span> <span class="nt">--all</span>


</pre></table></code></div></div><hr /><h3 id="启动已终止容器-docker-container-start">启动已终止容器 <code class="language-plaintext highlighter-rouge">docker container start</code></h3><p>将一个已经终止的容器启动运行。</p><ul><li>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。<li>除此之外，并没有其它的资源。<li>可 以在伪终端中利用 ps 或 top 来查看进程信息。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>root@ba267838cc1b:/# ps
  PID TTY          TIME CMD
    1 ?        00:00:00 bash
   11 ?        00:00:00 ps


可见，容器中仅运行了指定的 bash 应用。
这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚 拟化。
</pre></table></code></div></div><hr /><h3 id="daemon-运行-docker-run--d-ubuntu1804-binbash-whoami">Daemon 运行 <code class="language-plaintext highlighter-rouge">docker run -d ubuntu:18.04 /bin/bash whoami</code></h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c"># 1. 后台运行</span>
<span class="c"># 让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。</span>
<span class="c"># 通过添 加 -d 参数来实现。</span>

<span class="c"># 不使用 -d 参数运行容器。</span>
<span class="c"># 容器会把输出的结果 (STDOUT) 打印到宿主机上面</span>
<span class="nv">$ </span>docker run ubuntu:18.04 /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo hello world; sleep 1; done"</span>
hello world
hello world
hello world
hello world

<span class="c"># 使用了 -d 参数运行容器。</span>
<span class="c"># 此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> ubuntu:18.04 /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo hello world; sleep 1; done"</span>
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
<span class="c"># 输出结果可以用 docker logs 查 看</span>
<span class="nv">$ </span>docker container logs <span class="o">[</span>container ID or NAMES]
hello world
hello world
hello world
<span class="nb">.</span> <span class="nb">.</span> <span class="nb">.</span>

<span class="c"># 注: 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</span>
<span class="c"># 使用 -d 参数启动后会返回一个唯一的 id，</span>
<span class="c"># 可以通过 docker container ls 命令来查看容器信息。</span>
<span class="nv">$ </span>docker container <span class="nb">ls
</span>CONTAINER ID  IMAGE         COMMAND                  CREATED        STATUS             PORTS NAMES
77b2dc01fe0f  ubuntu:18.04  /bin/sh <span class="nt">-c</span> <span class="s1">'while tr..'</span>  2 minutes ago  Up 1 minute        agitated_wright
</pre></table></code></div></div><hr /><h3 id="终止容器-docker-container-stop">终止容器 <code class="language-plaintext highlighter-rouge">docker container stop</code></h3><ul><li>当 Docker 容器中指定的应用终结时，容器也自动终止。<li>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的 容器立刻终止。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c"># 终止状态的容器: docker container ls -a</span>
docker container <span class="nb">ls</span> <span class="nt">-a</span>
CONTAINER ID   IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES
ba267838cc1b   ubuntu:18.04             <span class="s2">"/bin/bash"</span>            30 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> About a minute ago                       trusting_newton
98e5efa7d997   training/webapp:latest   <span class="s2">"python app.py"</span>        About an hour ago   Exited <span class="o">(</span>0<span class="o">)</span> 34 minutes ago                           backstabbing_pike


<span class="c"># 处于终止状态的容器，通过 docker container start 命令来重新启动。</span>
<span class="c"># docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。</span>
</pre></table></code></div></div><hr /><h3 id="进入容器-docker-run--dit-ubuntu">进入容器 <code class="language-plaintext highlighter-rouge">docker run -dit ubuntu</code></h3><p>使用 <code class="language-plaintext highlighter-rouge">-d</code> 参数，容器启动后会进入后台。</p><ul><li>某些时候需要进入容器进行操作，包括使用 <code class="language-plaintext highlighter-rouge">docker attach</code> 命令或 <code class="language-plaintext highlighter-rouge">docker exec</code> 命令，<li>推荐使用 docker exec 命令</ul><blockquote><p>只用 -i 参数时，由于没有分配伪终端，界面没有熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。 -i -t 参数一起使用时，则可以看到Linux 命令提示符。</p></blockquote><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c"># docker attach 命令</span>
<span class="nv">$ </span>docker run <span class="nt">-dit</span> ubuntu
243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550

<span class="nv">$ </span>docker container <span class="nb">ls
</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
243c32535da7        ubuntu:latest       <span class="s2">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia

<span class="nv">$ </span>docker attach 243c
root@243c32535da7:/#
<span class="c"># 注意: 如果从这个 stdin 中 exit，会导致容器的停止。</span>



<span class="c"># exec 命令</span>
<span class="nv">$ </span>docker run <span class="nt">-dit</span> ubuntu
69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6

<span class="nv">$ </span>docker container <span class="nb">ls
</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
69d137adef7a        ubuntu:latest       <span class="s2">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           zealous_swirles

<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-i</span> 69d1 bash
<span class="nb">ls
</span>bin
boot
dev
...

<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> 69d1 bash
root@69d137adef7a:/#

<span class="c"># 如果从这个 stdin 中 exit，不会导致容器的停止。</span>
<span class="c"># 这就是为什么推荐大家使用docker exec</span>
</pre></table></code></div></div><hr /><h3 id="导出容器--docker-export-7691a814370e--ubuntutar">导出容器 <code class="language-plaintext highlighter-rouge">$ docker export 7691a814370e &gt; ubuntu.tar</code></h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 导出容器 docker export</span>
<span class="nv">$ </span>docker container <span class="nb">ls</span> <span class="nt">-a</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
7691a814370e        ubuntu:18.04        <span class="s2">"/bin/bash"</span>         36 hours ago        Exited <span class="o">(</span>0<span class="o">)</span> 21 hours ago                       <span class="nb">test</span>

<span class="nv">$ </span>docker <span class="nb">export </span>7691a814370e <span class="o">&gt;</span> ubuntu.tar
</pre></table></code></div></div><hr /><h3 id="导入容器--cat-ubuntutar--docker-import---testubuntuv10">导入容器 <code class="language-plaintext highlighter-rouge">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0</code></h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>导入 docker import

<span class="c"># 从容器快照文件中再导入为镜像</span>
<span class="nv">$ </span><span class="nb">cat </span>ubuntu.tar | docker import - <span class="nb">test</span>/ubuntu:v1.0

<span class="nv">$ </span>docker image <span class="nb">ls
</span>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
<span class="nb">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB


<span class="c"># 通过指定 URL 或者某个目录来导入</span>
<span class="nv">$ </span>docker import http://example.com/exampleimage.tgz example/imagerepo



<span class="c"># docker load 导入 镜像存储文件 到本地镜像库，</span>
<span class="c"># docker import 导入一个 容器快照 到本地镜像库。</span>
<span class="c"># 两者的区别在于</span>
<span class="c"># 容器快照文件将丢弃所有的历史记录和元数据信息(即仅 保存容器当时的快照状态)，</span>
<span class="c"># 而镜像存储文件将保存完整记录，体积也要大。</span>
<span class="c"># 此外，从容器快照文件导入时可以 重新指定标签等元数据信息。</span>
</pre></table></code></div></div><hr /><h3 id="docker-container-rm-ubuntu-删除容器"><code class="language-plaintext highlighter-rouge">docker container rm ubuntu</code> 删除容器</h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c"># 删除终止状态的容器</span>
<span class="nv">$ </span>docker container <span class="nb">rm </span>trusting_newton
trusting_newton

<span class="c"># 删除一个运行中的容器，</span>
<span class="c"># 添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</span>

<span class="c"># 对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。</span>
<span class="nv">$ </span>docker container <span class="nb">kill</span> <span class="o">[</span>containID]

<span class="c"># 清理所有处于终止状态的容器</span>
<span class="c"># 用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多，用下面的命令可以清理掉所有处于终止状态的容器。</span>
<span class="nv">$ </span>docker container prune
</pre></table></code></div></div><hr /><h2 id="访问仓库">访问仓库</h2><p><code class="language-plaintext highlighter-rouge">仓库( Repository )</code>是集中存放镜像的地方。</p><ul><li>一个容易混淆的概念是<code class="language-plaintext highlighter-rouge">注册服务器( Registry )</code>。<li>实际上 Registry 是管理 Repository 的具体服务器<li>每个 Registry 上可以有多个Repository，而每个Repository下面有多个镜像。<li>仓库可以被认为是一个具体的项目或目录。<li>例 如对于仓库地址 docker.io/ubuntu 来说， docker.io 是注册服务器地址， ubuntu 是仓库名。<li>大部分时候，并不需要严格区分这两者的概念。</ul><h3 id="docker-hub">Docker Hub</h3><ul><li>Docker 官方维护一个公共仓库 Docker Hub，其中已经包括了数量超过 2,650,000 的镜像。<li>大部分需求 都可以通过在 Docker Hub 中直接下载镜像来实现。<ul><li>注册 https://hub.docker.com<li>执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。<li>通过 docker logout 退出登录。<li>通过 docker search 命令来查找官方仓库中的镜像，<ul><li><code class="language-plaintext highlighter-rouge">$ docker search centos</code><li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/tsm4uv5.png" alt="Screen Shot 2020-11-27 at 23.47.30" /></ul><li>利用 docker pull 命令来将它下载到 本地。<ul><li><code class="language-plaintext highlighter-rouge">$ docker pull centos</code><li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/T5Dlbur.png" alt="Screen Shot 2020-11-27 at 23.46.59" /></ul><li>通过 docker push 将自己的镜像推送到 Docker Hub。<ul><li><code class="language-plaintext highlighter-rouge">$ docker push username/ubuntu:18.04</code><li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/6wlM31P.png" alt="Screen Shot 2020-11-27 at 23.50.11" /></ul></ul></ul><h3 id="自动构建-automated-builds">自动构建 Automated Builds</h3><p>对于需要经常升级镜像内程序来说十分方便。</p><ul><li>有时候，构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。<li>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站(支持 GitHub 或 BitBucket)上的项目，一旦项 目发生新的提交 (commit)或者创建了新的标签(tag)，Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># 要配置自动构建，包括如下的步骤:</span>

登录 Docker Hub<span class="p">;</span>
在 Docker Hub 点击右上角头像，在账号设置<span class="o">(</span>Account Settings<span class="o">)</span>中关联<span class="o">(</span>Linked Accounts<span class="o">)</span>目标网 站<span class="p">;</span>
在 Docker Hub 中新建或选择已有的仓库，在 Builds 选项卡中选择 Configure Automated Builds <span class="p">;</span>
选取一个目标网站中的项目<span class="o">(</span>需要含 Dockerfile <span class="o">)</span>和分支<span class="p">;</span>
指定 Dockerfile 的位置，并保存。
之后，可以在 Docker Hub 的仓库页面的 Timeline 选项卡中查看每次构建的状态。
</pre></table></code></div></div><hr /><h3 id="私有仓库">私有仓库</h3><p>用户可以创建一个本地仓库供私人使用。</p><ul><li><code class="language-plaintext highlighter-rouge">docker-registry</code> 是官方提供的工具，用于构建私有的镜像仓库。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="c"># 安装运行 docker-registry 容器运行</span>
<span class="c"># 通过获取官方 registry 镜像来运行。</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 5000:5000 <span class="nt">--restart</span><span class="o">=</span>always <span class="nt">--name</span> registry registry
<span class="c"># 这将使用官方的 registry 镜像来启动私有仓库。</span>


<span class="c"># 默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。</span>
<span class="c"># 通过 -v 参数来将镜像文件存放在本地的指定路径。</span>
<span class="c"># 例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 5000:5000 <span class="nt">-v</span> /opt/data/registry:/var/lib/registry registry



<span class="c"># 在私有仓库上传、搜索、下载镜像</span>
<span class="c"># 使用 docker tag 来标记一个镜像，然后推送它到仓库。</span>
<span class="c"># 例如私有仓库地址为 127.0.0.1:5000 。</span>

<span class="c"># 在本机查看已有的镜像。</span>
<span class="nv">$ </span>docker image <span class="nb">ls
</span>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB

<span class="c"># 使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest 。</span>
<span class="c"># 格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG] 。</span>
<span class="nv">$ </span>docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest
<span class="nv">$ </span>docker image <span class="nb">ls
</span>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB
127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB



<span class="c"># 用 curl 查看仓库中的镜像。</span>
<span class="nv">$ </span>curl 127.0.0.1:5000/v2/_catalog
<span class="o">{</span><span class="s2">"repositories"</span>:[<span class="s2">"ubuntu"</span><span class="o">]}</span>
<span class="c"># 这里可以看到 {"repositories":["ubuntu"]} ，表明镜像已经被成功上传了。</span>


<span class="c"># 先删除已有镜像，再尝试从私有仓库中下载这个镜像。</span>
<span class="nv">$ </span>docker image <span class="nb">rm </span>127.0.0.1:5000/ubuntu:latest

<span class="nv">$ </span>docker pull 127.0.0.1:5000/ubuntu:latest
Pulling repository 127.0.0.1:5000/ubuntu:latest ba5877dc9bec: Download <span class="nb">complete
</span>511136ea3c5a: Download <span class="nb">complete
</span>9bad880da3d2: Download <span class="nb">complete
</span>25f11f5fb0cb: Download <span class="nb">complete
</span>ebc34468f71d: Download <span class="nb">complete
</span>2318d26665ef: Download <span class="nb">complete</span>

<span class="nv">$ </span>docker image <span class="nb">ls
</span>REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB


注意事项
如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。
就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推 送镜像。
这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制， 或者查看下一节配置能够通过 HTTPS 访问的私有仓库。
</pre></table></code></div></div><hr /><h3 id="ubuntu-1604-debian-8-centos-7">Ubuntu 16.04+, Debian 8+, centos 7</h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容(如果文件不存在请新 建该文件)</span>
<span class="o">{</span>
  <span class="s2">"registry-mirror"</span>: <span class="o">[</span>
    <span class="s2">"https://registry.docker-cn.com"</span>
  <span class="o">]</span>,
  <span class="s2">"insecure-registries"</span>: <span class="o">[</span>
    <span class="s2">"192.168.199.100:5000"</span>
  <span class="o">]</span>
<span class="o">}</span>


注意:该文件必须符合 json 规范，否则 Docker 将不能启动。
</pre></table></code></div></div><hr /><h3 id="其他">其他</h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 辑 ，增加和上边一样的字符串即可。
</pre></table></code></div></div><hr /><h2 id="数据管理">数据管理</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://i.imgur.com/7WJZSlC.png" alt="types-of-mounts" /></p><p>在容器中管理数据主要有两种方式:</p><ul><li>数据卷(Volumes)<li>挂载主机目录 (Bind mounts)</ul><hr /><h3 id="数据卷volumes">数据卷(Volumes)</h3><ul><li>一个可供一个或多个容器使用的特殊目录<li>它绕过 UFS，可以提供很多有用的特性:<li>可以在容器之间共享和重用<li>对 数据卷 的修改会立马生效<li>对 数据卷 的更新，不会影响镜像<li>数据卷 默认会一直存在，即使容器被删除 注意: 数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中(仅数据卷为空时会复制)。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># 创建一个数据卷</span>
<span class="nv">$ </span>docker volume create my-vol

<span class="c"># 查看所有的 数据卷</span>
<span class="nv">$ </span>docker volume <span class="nb">ls
</span>DRIVER VOLUME NAME
<span class="nb">local </span>my-vol
</pre></table></code></div></div><hr /><h4 id="删除数据卷-docker-volume-rm-my-vol">删除数据卷 <code class="language-plaintext highlighter-rouge">docker volume rm my-vol</code></h4><p>数据卷 是被设计用来持久化数据的</p><ul><li>它的生命周期独立于容器，Docker 不会在容器被删除后自动删除<li>也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷 。<li>删除数据卷 <code class="language-plaintext highlighter-rouge">docker volume rm my-vol</code><li>如果需要在 删除容器的同时移除数据卷 <code class="language-plaintext highlighter-rouge">docker rm -v</code><li>无主的数据卷会占据很多空间，要清理请使用以下命令 <code class="language-plaintext highlighter-rouge">docker volume prune</code></ul><hr /><h4 id="启动一个挂载数据卷的容器">启动一个挂载数据卷的容器</h4><p>用 docker run 命令的时候</p><ul><li>使用 <code class="language-plaintext highlighter-rouge">--mount</code> 标记来将 数据卷 挂载到容器里。<li>在一次 docker run 中可以挂载多个 数据卷 。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># 创建一个名为 web 的容器，</span>
<span class="c"># 并加载一个 数据卷 到容器的 /usr/share/nginx/html 目录。</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-P</span> <span class="nt">--name</span> web <span class="se">\</span>
    <span class="c"># -v my-vol:/webapp \</span>
    <span class="nt">--mount</span> <span class="nb">source</span><span class="o">=</span>my-vol, <span class="nv">target</span><span class="o">=</span>/webapp <span class="se">\</span>
    training/webapp <span class="se">\</span>
    python app.py
</pre></table></code></div></div><hr /><h3 id="启动一个挂载主机目录的容器">启动一个挂载主机目录的容器</h3><ul><li>挂载一个主机目录作为数据卷<li>使用 –mount 标记可以指定挂载一个本地主机的目录到容器中去。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-P</span> <span class="nt">--name</span> web <span class="se">\</span>
    <span class="c"># -v /src/webapp:/opt/webapp \</span>
    <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bind</span>, <span class="nb">source</span><span class="o">=</span>/src/webapp, <span class="nv">target</span><span class="o">=</span>/opt/webapp <span class="se">\</span>
    training/webapp <span class="se">\</span>
    python app.py

<span class="c"># 上面的命令加载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html 目录。</span>
<span class="c"># 这个功能在进行 测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。</span>
<span class="c"># 本地目录的路径必 须是绝对路径，</span>
<span class="c"># 以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，</span>
<span class="c"># 现在使用--mount 参数时如果本地目录不存在，Docker 会报错。</span>

<span class="c"># Docker挂载主机目录的默认权限是 读写 ，用户也可以通过增加 readonly 指定为 只读 。</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-P</span> <span class="se">\</span>
    <span class="nt">--name</span> web <span class="se">\</span>
    <span class="c"># -v /src/webapp:/opt/webapp:ro \</span>
    <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bind</span>,source<span class="o">=</span>/src/webapp,target<span class="o">=</span>/opt/webapp,readonly <span class="se">\</span>
    training/webapp <span class="se">\</span>
    python app.py



<span class="c"># 加了 readonly 之后，就挂载为 只读 了。</span>
<span class="c"># 如果你在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误</span>
/opt/webapp <span class="c"># touch new.txt</span>
<span class="nb">touch</span>: new.txt: Read-only file system
</pre></table></code></div></div><hr /><h4 id="查看数据卷的具体信息--docker-inspect-web">查看数据卷的具体信息 <code class="language-plaintext highlighter-rouge">$ docker inspect web</code></h4><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c"># 在主机里使用以下命令可以查看 web 容器的信息</span>
<span class="nv">$ </span>docker inspect web
<span class="c"># 挂载主机目录 的配置信息在 "Mounts" Key 下面</span>
<span class="s2">"Mounts"</span>: <span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Type"</span>: <span class="s2">"bind"</span>,
        <span class="s2">"Source"</span>: <span class="s2">"/src/webapp"</span>,
        <span class="s2">"Destination"</span>: <span class="s2">"/opt/webapp"</span>,
        <span class="s2">"Mode"</span>: <span class="s2">""</span>,
        <span class="s2">"RW"</span>: <span class="nb">true</span>,
        <span class="s2">"Propagation"</span>: <span class="s2">"rprivate"</span>
    <span class="o">}</span>
<span class="o">]</span>,
</pre></table></code></div></div><hr /><h4 id="挂载一个本地主机文件作为数据卷">挂载一个本地主机文件作为数据卷</h4><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c"># 从主机挂载单个文件到容器中</span>
<span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="se">\</span>
   <span class="c"># -v $HOME/.bash_history:/root/.bash_history \</span>
   <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bind</span>, <span class="nb">source</span><span class="o">=</span><span class="nv">$HOME</span>/.bash_history, <span class="nv">target</span><span class="o">=</span>/root/.bash_history <span class="se">\</span>
   ubuntu:18.04 bash


<span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bind</span>, <span class="nb">source</span><span class="o">=</span><span class="nv">$HOME</span>/.bash_history, <span class="nv">target</span><span class="o">=</span>/root/.bash_history ubuntu:18.04 bash

root@2affd44b4667:/# <span class="nb">history
</span>1  <span class="nb">ls
</span>2  diskutil list

<span class="c"># 这样就可以记录在容器输入过的命令了。</span>
</pre></table></code></div></div><hr /><h2 id="网络">网络</h2><blockquote><p>Docker 中的网络功能介绍 Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p></blockquote><hr /><h3 id="外部访问容器">外部访问容器</h3><ul><li>容器中可以运行一些网络应用，要让外部也可以访问这些应用，通过 -P 或 -p 参数来指定端口映 射。<li>-P: Docker 会随机映射一个端口到内部容器开放的网络端口。<li>-p: 可以指定要映射的端口，<ul><li>并且，在一个指定端口上只可以绑定一个容器。<li>支持的格式有<li><code class="language-plaintext highlighter-rouge">ip:hostPort:containerPort</code><li><code class="language-plaintext highlighter-rouge">ip::containerPort</code><li><code class="language-plaintext highlighter-rouge">hostPort:containerPort</code></ul></ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>
<span class="c"># 使用 docker container ls 可以看到，本地主机的 32768 被映射到了容器的 80 端口。</span>
<span class="c"># 此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-P</span> training/webapp python app.py

<span class="nv">$ </span>docker container <span class="nb">ls</span> <span class="nt">-l</span>
CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES
bc533791f3f5  training/webapp:latest  python app.py 5 seconds ago  Up 2 seconds  0.0.0.0:49155-&gt;5000/tcp  nostalgic_morse



<span class="c"># 可以通过 docker logs 命令来查看应用的信息。</span>
<span class="nv">$ </span>docker logs <span class="nt">-f</span> nostalgic_morse
<span class="k">*</span> Running on http://0.0.0.0:5000/
10.0.2.2 - - <span class="o">[</span>23/May/2014 20:16:31] <span class="s2">"GET / HTTP/1.1"</span> 200 -
10.0.2.2 - - <span class="o">[</span>23/May/2014 20:16:31] <span class="s2">"GET /favicon.ico HTTP/1.1"</span> 404 -
</pre></table></code></div></div><blockquote><p>注意： 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</p></blockquote><p>-p 标记可以多次使用来绑定多个端口</p><p>例如</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 5000:5000 <span class="nt">-p</span> 3000:80 <span class="se">\</span>
    training/webapp <span class="se">\</span>
    python app.py
</pre></table></code></div></div><hr /><h4 id="映射所有接口地址--docker-run--d--p-50005000-trainingwebapp-python-apppy">映射所有接口地址 <code class="language-plaintext highlighter-rouge">$ docker run -d -p 5000:5000 training/webapp python app.py</code></h4><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c"># 使用 hostPort:containerPort 格式本地的 80 端口映射到容器的 80 端口:</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 5000:5000 training/webapp python app.py
此时默认会绑定本地所有接口上的所有地址。
</pre></table></code></div></div><hr /><h4 id="映射到指定地址的指定端口--docker-run--d--p-12700150005000-trainingwebapp-python-apppy">映射到指定地址的指定端口 <code class="language-plaintext highlighter-rouge">$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</code></h4><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 127.0.0.1:5000:5000 training/webapp python app.py
</pre></table></code></div></div><hr /><h4 id="映射到指定地址的任意端口">映射到指定地址的任意端口</h4><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 127.0.0.1::5000 training/webapp python app.py


<span class="c"># 还可以使用 udp 标记来指定 udp 端口</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 127.0.0.1:5000:5000/udp training/webapp python app.py
</pre></table></code></div></div><hr /><h4 id="查看映射端口配置--docker-port-container_name-5000">查看映射端口配置 <code class="language-plaintext highlighter-rouge">$ docker port container_name 5000</code></h4><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c"># 使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址</span>
<span class="nv">$ </span>docker port container_name 5000
127.0.0.1:49155.
</pre></table></code></div></div><hr /><h3 id="容器互联">容器互联</h3><p>容器互联</p><ul><li>使用 –link 参数来使容器互联。<li>将容器加入自定义的 Docker 网络来连接多个容器</ul><hr /><h3 id="新建网络--docker-network-create--d-bridge-my-net">新建网络 <code class="language-plaintext highlighter-rouge">$ docker network create -d bridge my-net</code></h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c"># 创建一个新的 Docker 网络。</span>
<span class="nv">$ </span>docker network create <span class="nt">-d</span> bridge my-net
<span class="c"># -d 参数指定 Docker 网络类型: bridge, overlay(用于 Swarm mode)</span>
</pre></table></code></div></div><hr /><h3 id="连接容器">连接容器</h3><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c"># 运行一个容器并连接到新建的 my-net 网络</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> busybox1 <span class="nt">--network</span> my-net busybox sh
<span class="c"># 打开新的终端，再运行一个容器并加入到 my-net 网络</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> busybox2 <span class="nt">--network</span> my-net busybox sh
<span class="c"># 再打开一个新的终端查看容器信息</span>
<span class="nv">$ </span>docker container <span class="nb">ls

</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b47060aca56b        busybox             <span class="s2">"sh"</span>                11 minutes ago      Up 11 minutes                           busybox2
8720575823ec        busybox             <span class="s2">"sh"</span>                16 minutes ago      Up 16 minutes                           busybox1


<span class="c"># 通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。</span>
<span class="c"># 在 busybox1 容器输入以下命令</span>
/ <span class="c"># ping busybox2</span>
PING busybox2 <span class="o">(</span>172.19.0.3<span class="o">)</span>: 56 data bytes
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>0 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.072 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.118 ms
<span class="c"># 用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。</span>


<span class="c"># 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。</span>
/ <span class="c"># ping busybox1</span>
PING busybox1 <span class="o">(</span>172.19.0.2<span class="o">)</span>: 56 data bytes
64 bytes from 172.19.0.2: <span class="nb">seq</span><span class="o">=</span>0 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.064 ms
64 bytes from 172.19.0.2: <span class="nb">seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.143 ms


<span class="c"># 这样， busybox1 容器和 busybox2 容器建立了互联关系。</span>


Docker Compose
如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。
</pre></table></code></div></div><hr /><h3 id="配置-dns">配置 DNS</h3><p>自定义配置容器的主机名和 DNS</p><ul><li>Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</ul><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="c"># 在容器中使用 mount 命令可以看到挂载信息：</span>
<span class="c"># 这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。</span>
<span class="nv">$ </span>mount
/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="nb">type </span>ext4 ...
/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="nb">type </span>ext4 ...
tmpfs on /etc/resolv.conf <span class="nb">type </span>tmpfs ...



<span class="c"># 也可以在 /etc/docker/daemon.json 文件中增加以下内容来设置。配置全部容器的 DNS.</span>
<span class="c"># 这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。</span>
<span class="o">{</span>
  <span class="s2">"dns"</span> : <span class="o">[</span>
    <span class="s2">"114.114.114.114"</span>,
    <span class="s2">"8.8.8.8"</span>
  <span class="o">]</span>
<span class="o">}</span>


<span class="c"># 使用以下命令来证明其已经生效。</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> ubuntu:18.04 <span class="nb">cat </span>etc/resolv.conf
nameserver 114.114.114.114
nameserver 8.8.8.8



<span class="c"># 手动指定容器的配置，在使用 docker run 命令启动容器时加入如下参数:</span>
<span class="c"># -h HOSTNAME, --hostname=HOSTNAME</span>
    <span class="c"># 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts 。</span>
    <span class="c"># 但它在容器外部看不到，既不会在 docker container ls 中 显示，也不会在其他的容器的 /etc/hosts 看到。</span>

<span class="c"># --dns=IP_ADDRESS</span>
    <span class="c"># 添加 DNS 服务器到容器的 /etc/resolv.conf 中</span>
    <span class="c"># 让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</span>

<span class="c"># --dns-search=DOMAIN</span>
    <span class="c"># 设定容器的搜索域</span>
    <span class="c"># 当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com</span>

<span class="c"># 注意:如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 /etc/resolv.conf 来配 置容器。</span>
</pre></table></code></div></div><hr /><h2 id="高级网络配置">高级网络配置</h2><hr /><h2 id="docker-compose">Docker Compose</h2><p>Docker Compose</p><ul><li>Docker 官方编排(Orchestration)开源项目之一<li>负责实现对 Docker 容器集群的快速编排。<li>从功能上看，跟OpenStack 中的 Heat 十分类似。<li>其代码目前在 https://github.com/docker/compose 上开源。<li>Compose 定位是 「定义和运行多个 Docker 容器的应用(Defining and running multi-container Docker applications)」，其前身是开源项目 Fig。</ul><p>使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。</p><ul><li>然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。<li>例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</ul><p>Compose 恰好满足了这样的需求。</p><ul><li>它允许用户通过一个单独的 docker-compose.yml 模板文件 (YAML 格式)来定义一组相关联的应用容器为一个项目(project)。</ul><p>Compose 中有两个重要的概念:</p><ul><li><code class="language-plaintext highlighter-rouge">服务 ( service )</code>:<ul><li>一个应用的容器，<li>实际上可以包括若干运行相同镜像的容器实例。</ul><li><code class="language-plaintext highlighter-rouge">项目 ( project )</code>:<ul><li>由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文 件中定义。</ul><li>一个 project 可以由多个 service（容器）关联而成<li>Compose 面向 project 进行管理。<li>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</ul><p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。</p><ul><li>因此，只要所操 作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</ul><hr /><h3 id="安装与卸载">安装与卸载</h3><p><code class="language-plaintext highlighter-rouge">Compose</code> 支持 Linux、macOS、Windows 10 三大平台。</p><p><code class="language-plaintext highlighter-rouge">Compose</code> 可以通过 Python 的包管理工具 <code class="language-plaintext highlighter-rouge">pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p><p><code class="language-plaintext highlighter-rouge">Docker Desktop for Mac/Windows</code> 自带 <code class="language-plaintext highlighter-rouge">docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>$ docker-compose --version

docker-compose version 1.24.1, build 4667896b
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="c"># Linux安装。</span>

<span class="c"># 二进制包</span>
<span class="c"># 从 [官方 GitHub Release](https://github.com/docker/compose/releases) 处直接下载编译好的二进制文件即可。</span>
<span class="c"># 例如，在 Linux 64 位系统上直接下载对应的二进制包。</span>

<span class="nv">$ </span><span class="nb">sudo </span>curl <span class="nt">-L</span> https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="sb">`</span><span class="nb">uname</span> <span class="nt">-s</span><span class="sb">`</span>-<span class="sb">`</span><span class="nb">uname</span> <span class="nt">-m</span><span class="sb">`</span> <span class="o">&gt;</span> /usr/local/bin/docker-compose

<span class="nv">$ </span><span class="nb">sudo chmod</span> +x /usr/local/bin/docker-compose


<span class="c"># PIP 安装</span>
<span class="c"># _注：_ `x86_64` 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 `ARM` (例如，树莓派)，再使用 `pip` 安装。</span>
<span class="c"># 这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</span>

<span class="c"># 执行安装命令：</span>
<span class="nv">$ </span><span class="nb">sudo </span>pip <span class="nb">install</span> <span class="nt">-U</span> docker-compose
<span class="c"># 可以看到类似如下输出，说明安装成功。</span>
Collecting docker-compose
Downloading docker-compose-1.24.1.tar.gz <span class="o">(</span>149kB<span class="o">)</span>: 149kB downloaded
...
Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty sienum34 backports.ssl-match-hostname ipaddress


<span class="c"># bash 补全命令</span>
<span class="nv">$ </span>curl <span class="nt">-L</span> https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose <span class="o">&gt;</span> /etc/bash_completion.d/docker-compose


<span class="c"># 卸载</span>

<span class="c"># 如果是二进制包方式安装的，删除二进制文件即可。</span>

    <span class="nv">$ </span><span class="nb">sudo rm</span> /usr/local/bin/docker-compose


<span class="c"># 如果是通过 `pip` 安装的，则执行如下命令即可删除。</span>

    <span class="nv">$ </span><span class="nb">sudo </span>pip uninstall docker-compose
</pre></table></code></div></div><hr /><p>ref</p><ul><li><a href="http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html">Visualizing Docker Containers and Images</a></ul><p>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/19vms/'>19VMs</a>, <a href='/categories/containers/'>Containers</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/linux/" class="post-tag no-text-decoration" >Linux</a> <a href="/tags/vms/" class="post-tag no-text-decoration" >VMs</a> <a href="/tags/docker/" class="post-tag no-text-decoration" >Docker</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Virtulization - Docker Note - Grace&url=https://ocholuo.github.io//posts/Docker/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Virtulization - Docker Note - Grace&u=https://ocholuo.github.io//posts/Docker/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Virtulization - Docker Note - Grace&url=https://ocholuo.github.io//posts/Docker/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://ocholuo.github.io//posts/Docker/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/CI-CD/">CI/CD - Continuous Integration & Continous Delivery</a><li><a href="/posts/Github-Action-example/">CI/CD - Github Action Template</a><li><a href="/posts/CloudMap/">AWS - EKS - Cloud Map</a><li><a href="/posts/DataWrangler/">AWS - ML - Data Wrangler</a><li><a href="/posts/0CodePipeline/">AWS - CodeDevelop - CodePipeline</a><li><a href="/posts/1CodeCommit/">AWS - CodeDevelop - CodeCommit</a><li><a href="/posts/2CodeBuild/">AWS - CodeDevelop - CodeBuild</a><li><a href="/posts/2CodeBuildTemplate-buildspec/">AWS - CodeDevelop - CodeBuild - buildspec.yml Template</a><li><a href="/posts/ElasticBeanstalk/">AWS - CodeDevelop - ElasticBeanstalk</a><li><a href="/posts/CourseREADME/">Course - Learning Path</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/soc/">SOC</a> <a class="post-tag" href="/tags/network/">Network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Docker-dev/"><div class="card-body"> <span class="timeago small" > Nov 26, 2020 <i class="unloaded">2020-11-26T10:11:11-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtulization - DockerFile Develop</h3><div class="text-muted small"><p> [toc] DockerFile Develop Best practices for writing Dockerfiles Docker builds images automatically by reading the instructions from a Dockerfile a text file that contains all commands, in o...</p></div></div></a></div><div class="card"> <a href="/posts/Docker-security/"><div class="card-body"> <span class="timeago small" > Nov 26, 2020 <i class="unloaded">2020-11-26T10:11:11-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtulization - Docker security</h3><div class="text-muted small"><p> [toc] Docker security basic 评估 Docker 的安全性时，主要考虑三个方面: 由内核的命名空间和控制组机制提供的 容器内在安全 Docker 程序（特别是服务端）本身的抗攻击性 内核安全性的加强机制 对 容器安全性的影响 namespace Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。 当用 do...</p></div></div></a></div><div class="card"> <a href="/posts/kali-in-docker/"><div class="card-body"> <span class="timeago small" > Nov 26, 2020 <i class="unloaded">2020-11-26T10:11:11-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtulization - Running Kali on Docker</h3><div class="text-muted small"><p> [toc] Running Kali on Docker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Installing Docker on Linux $ sudo apt install docker.io # create folder # make a folder on our ho...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Docker-security/" class="btn btn-outline-primary" prompt="Older"><p>Virtulization - Docker security</p></a> <a href="/posts/Kubernetes/" class="btn btn-outline-primary" prompt="Newer"><p>Virtulization - Google Kubernetes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//https-ocholuo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Virtulization - Docker Note'; this.page.url = 'https://ocholuo.github.io//posts/Docker/'; this.page.identifier = '/posts/Docker/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/soc/">SOC</a> <a class="post-tag" href="/tags/network/">Network</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>

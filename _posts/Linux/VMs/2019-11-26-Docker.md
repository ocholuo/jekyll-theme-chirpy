---
title: Docker Note
date: 2019-11-26 11:11:11 -0400
categories: [Linux, VMs]
tags: [Linux, VMs, Docker]
math: true
image:
---

[toc]

---

# Docker Note

---

## Docker

- developed with GO launched by Google,
- based on cgroup and namespace of Linux Kernel and Union FS like AUFS to `package and isolate the processes` which belong to `Operating system level virtualization technology`.
- It is also called container because of the fact that the isolated processes are independent of the host and other isolated processes.
- The initial implementation is based on LXC.
- It removed LXC and use libcontainer instead which is developed by themself since 0.7. Starting with 1.11, it uses runC and containerd further.

![docker-on-linux](https://i.imgur.com/U1jdplX.png)

> `runc` is a Linux command-line tool for creating and running containers according to the OCI container runtime specification.

> `containerd` is a daemon that manages container life cycle from downloading and unpacking the container image to container execution and supervision.

Docker is further packaged on a container basis, from file system, network interconnection to process isolation, etc, greatly simplifying container craetion and maintenance.

The images below compare the differences between Docker and Traditional Virtualization.
- The **traditional Virtual Machine technology** : virtualize a set of hardwares to `run a complete operation system` and `run the required application process` on this system.  
- The application process in the container `runs directly on the host kernel`, and the container does not have its own Kernel and hardware virtualiztion. Therefore, containers are lighter than traditional virtual machines.

![virtualization](https://i.imgur.com/XdauvJG.png)

![docker](https://i.imgur.com/ULoJiCf.png)

---

## Why use Docker ?

Docker 跟传统的虚拟化方式相比具有众多的优势。

1. 更高效的利用系统资源
   - 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销， Docker 对系统资源的利用率更高。无论是 应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同 配置的主机，往往可以运行更多数量的应用。

2. 更快速的启动时间 Faster Startup Time
   - 传统的虚拟机技术启动应用服务往往需要数分钟，
   - Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。
   - 节约了开发、测试、部署的时间。

3. 一致的运行环境 Consistent Operating Environment
   - 开发过程中一个常见的问题是环境一致性问题。
     - 由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未 在开发过程中被发现。
   - 而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性， 从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。


4. 持续交付和部署 CI/CD
   - 对开发和运维(DevOps)人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。
   - create and configure once to run anywhere.
   - 使用 Docker 可以通过定制`应用镜像 application mirrors with Docker`来实现持续集成、持续交付、部署。
   - **Developers**: **build images with Dockerfile** and use `Continuous Integration for integration testing`.
   - **Operation teams**: **deploy production environments quickly with the images**, and even **make automatic deployments** possible by using `Continuous Delivery/Deployment techniques`.
   - 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应 用运行所需条件，帮助更好的生产环境中部署该镜像。


5. 更轻松的迁移 Easier migration
   - 由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。
   - Docker 可以在很多平台上运行，无 论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。
   - 因此用户可以很轻易的将在一个 平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。


6. 更轻松的维护和扩展
   - Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。
   - Docker 团队同各个开源项目团队一起维护了高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大降低了应用服务的镜像 制作成本。


对比传统虚拟机总结

![Screen Shot 2020-11-25 at 01.57.58](https://i.imgur.com/NOjFPJV.png)

---

## 基本概念

基本概念 Docker 包括三个基本概念
- 镜像( Image )
- 容器( Container )
- 仓库( Repository )


---


### Docker 镜像

操作系统分为内核和用户空间。
- 对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提 供用户空间支持。
- 而 Docker 镜像(Image)，就相当于是一个 root 文件系统。
- 比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。
- Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一 些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。
- 镜像不包含任何动态数据，其内容在构建之 后也不会被改变。


#### 分层存储 Advanced Multi-layered Unification Filesystem (AUFS)
因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的
- 因此在 Docker 设计时，就充分利用 `Union FS` 的技术，将其设计为分层存储的架构。
- 所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联 合组成。
- 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只 发生在自己这一层。
  - 比如，
  - 删除前一层文件的操作，
  - 实际不是真的删除前一层的文件，
  - 而是仅在当前层标记为该 文件已删除。
  - 在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。
- 因此，在构 建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前 清理掉。
- 分层存储的特征还使得镜像的复用、定制变的更为容易。
- 甚至可以用之前构建好的镜像作为基础层，然后进一步 添加新的层，以定制自己所需的内容，构建新的镜像。

---

### Docker 容器
- 镜像( Image )和容器( Container )的关系，就像是面向对象程序设计中的 类 和 实例 一样
- 镜像是静态的定义，
- 容器是镜像运行时的实体。
  - 容器可以被创建、启动、停止、删除、暂停等。
  - 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。
- 因此容器可 以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。
- 容器内的进程 是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。
- 这种特性使得容器封装 的应用比直接在宿主运行更加安全。
  - 因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。
- `multi-layered filesystem` is applied to **images**, and so as the **containers**.
  - When a container is running, it is based on its image, with a writable layer created on top of it.
  - We call this layer prepared for R/W at runtime `Container Layer`
  - `容器存储层`的生存周期和容器一样
    - 容器消亡时，容器存储层也随之消亡。
    - 因此任何保存于容器存储层的信息 都会随容器删除而丢失。


> recommended by the Docker Development Best Practices

**should not write any data to the `container layer`**
- make it stateless.
- All file write operations should adhere to `Volume` or `bind mounts`.
- `Writing to volume or bind mounts` skips the container layer and `R/W to host storage(or network storage) directly`
  - achieves better performance and stability.
- 数据卷的生存周期独立于容器
  - 容器消亡，数据卷不会消亡。
  - 因此使用数据卷后，容器删除或者重新运行之 后，数据却不会丢失。

---

### 仓库 Docker Registry

After the construction of an image, we can easily run it on a host.
- but, to use the image on other servers, need a centralized image storage and distribution service, **Docker Registry**.
- 一个 Docker Registry 中可以包含多个 `仓库( Repository )`;
- 每个仓库可以包含多个 `标签( Tag )`;
- 每个标签对应一个`镜像`。
  - 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。
  - 通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。
  - 如果不给出标签，将以 `latest` 作为 默认标签。


以 Ubuntu 镜像 为例，
- ubuntu 是仓库的名字，其内包含有不同的版本标签，如， 16.04 , 18.04 。
- 我们可以通过 ubuntu:16.04 ，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。
- 如果忽略了标 签，比如 ubuntu ，那将视为 ubuntu:latest 。


仓库名经常以 两段式路径 形式出现，
- 比如 jwilder/nginx-proxy ，前者往往意味着 Docker Registry 多 用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软 件或服务。

#### Docker Registry 公开服务
- 开放给用户使用、允许用户管理镜像的 Registry 服务。
- 一般这类公开服务允许用户 免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。
- 最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜 像。
- 除此以外，还有 Red Hat 的 Quay.io;Google 的 Google Container Registry，Kubernetes 的镜像使用 的就是这个服务。


#### 私有 Docker Registry
- 除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。
- Docker 官方提供了 Docker Registry 镜 像，可以直接使用做为私有 Registry 服务。


---


## 安装 Docker

Docker 分为 stable test 和 nightly 三个更新频道。

---

### Ubuntu 安装 Docker

```bash
# 警告:切 勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.

准备工作 系统要求
Docker 支持以下版本的 Ubuntu 操作系统:
Ubuntu Focal 20.04 (LTS)
Bionic 18.04 (LTS)
Xenial 16.04 (LTS)


# Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS(Long-Term-Support)长期 支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。

# 卸载旧版本 旧版本的 Docker 称为 docker 或者 docker-engine
$ sudo apt-get remove docker \ docker-engine \ docker.io

# 使用 APT 安装
由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件 包以及 CA 证书。
$ sudo apt-get update
$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \
gnupg-agent \ software-properties-common
鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。

为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。
$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-
key add -
# 官方源
# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
然后，我们需要向 sources.list 中添加 Docker 软件源
   $
# # # # #
sudo add-apt-repository \
"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \
stable"
官方源
$ sudo add-apt-repository \
"deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \
stable"
以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。
安装 Docker
更新 apt 软件包缓存，并安装 docker-ce :
$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io
使用脚本自动安装
在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这
套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装: 若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本
# $ curl -fsSL test.docker.com -o get-docker.sh $ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh --mirror Aliyun

# $ sudo sh get-docker.sh --mirror AzureChinaCloud
执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。 启动 Docker
  $ sudo systemctl enable docker
  $ sudo systemctl start docker
建立 docker 用户组
默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用 户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。
建立 docker 组:
  $ sudo groupadd docker
# 将当前用户加入 docker 组:
$ sudo usermod -aG docker $USER

# 退出当前终端并重新登录，进行如下测试。 测试 Docker 是否安装正确
$ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
d1725b59e92d: Pull complete
Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest
Hello from Docker!
This message shows that your installation appears to be working correctly.
  To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.

4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.
To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/
For more examples and ideas, visit: https://docs.docker.com/get-started/
若能正常输出以上信息，则说明安装成功。 镜像加速
```

### Debian 安装 Docker

```
警告:切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.
准备工作 系统要求
Docker 支持以下版本的 Debian 操作系统: Buster 10
Stretch 9 卸载旧版本
旧版本的 Docker 称为 docker 或者 docker-engine ，使用以下命令卸载旧版本:
$ sudo apt-get remove docker \ docker-engine \
docker.io
使用 APT 安装
由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包 以及 CA 证书。
$ sudo apt-get update
$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \
gnupg-agent \
lsb-release \ software-properties-common
鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。
$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-

- 30 -

Debian
 key add -
# 官方源
# $ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
然后，我们需要向 sources.list 中添加 Docker 软件源:
  $
# # # # #
sudo add-apt-repository \
"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian \ $(lsb_release -cs) \
stable"
官方源
$ sudo add-apt-repository \
"deb [arch=amd64] https://download.docker.com/linux/debian \ $(lsb_release -cs) \
stable"
以上命令会添加稳定版本的 Docker APT 源，如果需要测试版本的 Docker 请将 stable 改为 test。
安装 Docker
更新 apt 软件包缓存，并安装 docker-ce 。
$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io
使用脚本自动安装
在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Debian 系统上可以使用这
套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装: 若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本
# $ curl -fsSL test.docker.com -o get-docker.sh
$ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh --mirror Aliyun
# $ sudo sh get-docker.sh --mirror AzureChinaCloud
执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。

Debian
启动 Docker
  $ sudo systemctl enable docker
  $ sudo systemctl start docker
建立 docker 用户组
默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用 户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。
建立 docker 组:
  $ sudo groupadd docker
将当前用户加入 docker 组:
$ sudo usermod -aG docker $USER
退出当前终端并重新登录，进行如下测试。 测试 Docker 是否安装正确
$ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
d1725b59e92d: Pull complete
Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest
Hello from Docker!
This message shows that your installation appears to be working correctly.
  To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.
To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash

- 32 -

Debian
 Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/
For more examples and ideas, visit: https://docs.docker.com/get-started/
若能正常输出以上信息，则说明安装成功。 镜像加速
如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。 参考文档
Docker 官方 Debian 安装文档
- 33 -
```

### Fedora 安装 Docker

```
警告:切勿在没有配置 Docker dnf 源的情况下直接使用 dnf 命令安装 Docker.
准备工作 系统要求
Docker 支持以下版本的 Fedora 操作系统:
30 31 32
卸载旧版本
旧版本的 Docker 称为 docker 或者 docker-engine ，使用以下命令卸载旧版本:
$ sudo dnf remove docker \ docker-client \
docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine
使用 dnf 安装 执行以下命令安装依赖包:
$ sudo dnf -y install dnf-plugins-core
鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 执行下面的命令添加 dnf 软件源:
$ sudo dnf config-manager \ --add-repo \

- 34 -

Fedora
 https://mirrors.ustc.edu.cn/docker-ce/linux/fedora/docker-ce.repo
$ sudo sed -i 's/download.docker.com/mirrors.ustc.edu.cn\/docker-ce/g' /etc/yum .repos.d/docker-ce.repo
# # # #
官方源
$ sudo dnf config-manager \ --add-repo \
https://download.docker.com/linux/fedora/docker-ce.repo
如果需要测试版本的 Docker 请使用以下命令:
$ sudo dnf config-manager --set-enabled docker-ce-test
你也可以禁用测试版本的 Docker
$ sudo dnf config-manager --set-disabled docker-ce-test
安装 Docker
更新 dnf 软件源缓存，并安装 docker-ce 。
$ sudo dnf update
$ sudo dnf install docker-ce docker-ce-cli containerd.io
你也可以使用以下命令安装指定版本的 Docker
$ dnf list docker-ce --showduplicates | sort -r
docker-ce.x86_64 18.06.1.ce-3.fc28 docker-ce-stabl e
$ sudo dnf -y install docker-ce-18.06.1.ce
由于 Fedora 31 默认启用了 Cgroupv2，稳定版本的 Docker 与 Cgroupv2 不兼容，你可以安装测试版 Docker，或者执行以下命令切换到 Cgroupv1 并重启计算机:
$ sudo grubby --update-kernel=ALL --args="systemd.unified_cgroup_hierarchy=0"
使用脚本自动安装
在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Debian 系统上可以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装: 若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本
# $ curl -fsSL test.docker.com -o get-docker.sh
$ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh --mirror Aliyun
# $ sudo sh get-docker.sh --mirror AzureChinaCloud
执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 最新稳定(stable)版本安装在系统中。 启动 Docker
  $ sudo systemctl enable docker
  $ sudo systemctl start docker
建立 docker 用户组
默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用 户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。
建立 docker 组:
  $ sudo groupadd docker
将当前用户加入 docker 组:
$ sudo usermod -aG docker $USER
退出当前终端并重新登录，进行如下测试。 测试 Docker 是否安装正确
$ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
d1725b59e92d: Pull complete
Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest
  Hello from Docker!

- 36 -

Fedora
 This message shows that your installation appears to be working correctly.
  To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.
To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/
For more examples and ideas, visit: https://docs.docker.com/get-started/
若能正常输出以上信息，则说明安装成功。 镜像加速
如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。 参考文档
Docker 官方 Fedora 安装文档。
```


### CentOS 安装 Docker

```
警告:切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.
准备工作
系统要求
Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由
于内核版本比较低，部分功能(如 overlay2 存储层驱动)无法使用，并且部分功能可能不太稳定。 卸载旧版本
旧版本的 Docker 称为 docker 或者 docker-engine ，使用以下命令卸载旧版本:
$ sudo yum remove docker \ docker-client \
docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine
使用 yum 安装 执行以下命令安装依赖包:
$ sudo yum install -y yum-utils
鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 执行下面的命令添加 yum 软件源:
$ sudo yum-config-manager \ --add-repo \
https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo
$ sudo sed -i 's/download.docker.com/mirrors.ustc.edu.cn\/docker-ce/g' /etc/yum .repos.d/docker-ce.repo

- 38 -

CentOS
 # # # #
官方源
$ sudo yum-config-manager \ --add-repo \
https://download.docker.com/linux/centos/docker-ce.repo
如果需要测试版本的 Docker (或你的系统是 CentOS 8)请执行以下命令:
$ sudo yum-config-manager --enable docker-ce-test
安装 Docker
更新 yum 软件源缓存，并安装 docker-ce 。
$ sudo yum install docker-ce docker-ce-cli containerd.io
CentOS8 额外设置
由于 CentOS8 防火墙使用了 nftables ，但 Docker 尚未支持 nftables ， 我们可以使用如下设置使用 iptables :
更改 /etc/firewalld/firewalld.conf # FirewallBackend=nftables
  FirewallBackend=iptables
或者执行如下命令:
$ firewall-cmd --permanent --zone=trusted --add-interface=docker0 $ firewall-cmd --reload
使用脚本自动安装
在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这
套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装:
若你想安装测试版的 Docker(或你的系统是 CentOS 8), 请从 test.docker.com 获取脚本
# $ curl -fsSL test.docker.com -o get-docker.sh
$ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh --mirror Aliyun
# $ sudo sh get-docker.sh --mirror AzureChinaCloud
- 39 -

CentOS
 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。 启动 Docker
  $ sudo systemctl enable docker
  $ sudo systemctl start docker
建立 docker 用户组
默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用 户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。
建立 docker 组:
  $ sudo groupadd docker
将当前用户加入 docker 组:
$ sudo usermod -aG docker $USER
退出当前终端并重新登录，进行如下测试。 测试 Docker 是否安装正确
$ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
d1725b59e92d: Pull complete
Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest
Hello from Docker!
This message shows that your installation appears to be working correctly.
  To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it

- 40 -

CentOS
 to your terminal.
To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/
For more examples and ideas, visit: https://docs.docker.com/get-started/
若能正常输出以上信息，则说明安装成功。 镜像加速
如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。 添加内核参数
如果在 CentOS 使用 Docker 看到下面的这些警告信息:
WARNING: bridge-nf-call-iptables is disabled WARNING: bridge-nf-call-ip6tables is disabled
请添加内核配置参数以启用这些功能。
$ sudo tee -a /etc/sysctl.conf <<-EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF
然后重新加载 sysctl.conf 即可 $ sudo sysctl -p
参考文档
Docker 官方 CentOS 安装文档。 https://firewalld.org/2018/07/nftables-backend https://github.com/moby/libnetwork/issues/2496
```

### Raspberry Pi 安装 Docker

```
警告:切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.
系统要求
Docker 不仅支持 x86_64 架构的计算机，同时也支持 ARM 架构的计算机，本小节内容以树莓派单片电脑 为例讲解 ARM 架构安装 Docker。
Docker 支持以下版本的 Raspberry Pi OS 操作系统:
Raspberry Pi OS Buster
注: Raspberry Pi OS 由树莓派的开发与维护机构 树莓派基金会 官方支持，并推荐用作树莓派的首选系
统，其基于 Debian 。 使用 APT 安装
由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包 以及 CA 证书。
$ sudo apt-get update
$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \
gnupg2 \
lsb-release \ software-properties-common
鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。
$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/raspbian/gpg | sudo ap t-key add -
# 官方源
# $ curl -fsSL https://download.docker.com/linux/raspbian/gpg | sudo apt-key ad d-

 然后，我们需要向 sources.list 中添加 Docker 软件源:
 $
# # # # #
sudo add-apt-repository \
"deb [arch=armhf] https://mirrors.ustc.edu.cn/docker-ce/linux/raspbian \ $(lsb_release -cs) \
stable"
官方源
$ sudo add-apt-repository \
"deb [arch=armhf] https://download.docker.com/linux/raspbian \ $(lsb_release -cs) \
stable"
以上命令会添加稳定版本的 Docker APT 源，如果需要测试版本的 Docker 请将 stable 改为 test。
安装 Docker
更新 apt 软件包缓存，并安装 docker-ce 。
$ sudo apt-get update
$ sudo apt-get install docker-ce
使用脚本自动安装
在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Raspberry Pi OS 系统上可
以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装: 若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本
# $ curl -fsSL test.docker.com -o get-docker.sh
$ curl -fsSL get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh --mirror Aliyun
# $ sudo sh get-docker.sh --mirror AzureChinaCloud
执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。 启动 Docker
  $ sudo systemctl enable docker
  $ sudo systemctl start docker
- 43 -

Raspberry Pi
建立 docker 用户组
默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用 户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。
建立 docker 组:
  $ sudo groupadd docker
将当前用户加入 docker 组:
$ sudo usermod -aG docker $USER
退出当前终端并重新登录，进行如下测试。 测试 Docker 是否安装正确
$ docker run arm32v7/hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
d1725b59e92d: Pull complete
Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest
Hello from Docker!
This message shows that your installation appears to be working correctly.
  To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.
To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/
For more examples and ideas, visit: https://docs.docker.com/get-started/
- 44 -

Raspberry Pi
 若能正常输出以上信息，则说明安装成功。
注意: ARM 平台不能使用 x86 镜像，查看 Raspberry Pi OS 可使用镜像请访问 arm32v7 或者 arm64v8。
镜像加速
如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。


```

### Linux 离线安装 离线部署Docker

```
离线部署Docker
Centos7 离线安装Docker
YUM本地文件安装(推荐) 查询可用的软件版本(A) 下载到指定文件夹(A) 复制到目标服务器之后进入文件夹安装(C-N) 锁定软件版本(C-N)
         下载锁定版本软件
         锁定软件版本
         查看锁定列表
         锁定后无法再更新
         解锁指定软件
         解锁所有软件
YUM 本地源服务器搭建安装Docker
挂载 ISO 镜像搭建本地 File 源(AB) 根据本地文件搭建BASE网络源(B) 下载Docker-CE 镜像仓库(A) 创建仓库索引(B)
YUM 客户端设置(C...N)
Docker 安装(C...N)
生产环境中一般都是没有公网资源的，本文介绍如何在生产服务器上离线部署 Docker 括号内的字母表示该操作需要在哪些服务器上执行
- 46 -

Linux 离线安装
 Centos7 离线安装Docker
YUM本地文件安装(推荐) 推荐这种方式，是因为在生产环境种一般会选定某个指定的文档软件版本使用。 查询可用的软件版本(A)
#下载清华的镜像源文件
wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/cento s/docker-ce.repo
sudo sed -i 's+download.docker.com+mirrors.tuna.tsinghua.edu.cn/docker-ce+' /et c/yum.repos.d/docker-ce.repo
  yum update
sudo yum list docker-ce --showduplicates|sort -r
Loading mirror speeds from cached hostfile
Loaded plugins: fastestmirror
 docker-ce.x86_64 e docker-ce.x86_64 e docker-ce.x86_64 e docker-ce.x86_64 e docker-ce.x86_64 e docker-ce.x86_64 e docker-ce.x86_64 e docker-ce.x86_64 e
....
下载到指定文件夹(A)
3:19.03.8-3.el7 3:19.03.7-3.el7 3:19.03.6-3.el7 3:19.03.5-3.el7 3:19.03.4-3.el7 3:19.03.3-3.el7 3:19.03.2-3.el7 3:19.03.1-3.el7
docker-ce-stabl docker-ce-stabl docker-ce-stabl docker-ce-stabl docker-ce-stabl docker-ce-stabl docker-ce-stabl docker-ce-stabl
- 47 -

Linux 离线安装
 sudo yum install --downloadonly --downloaddir=/tmp/docker-19.03 docker-ce-19.03 .8-3.el7 docker-ce-cli-19.03.8-3.el7
Dependencies Resolved
===============================================================================
===============================================================================
======================
 Package
        Version
Arch
                 Size
===============================================================================
===============================================================================
======================
Installing:
docker-ce 3:19.03.8-3.el7
                 25 M
Installing for dependencies:
container-selinux 2:2.107-3.el7
39 k
containerd.io 1.2.13-3.1.el7
23 M
docker-ce-cli 1:19.03.8-3.el7
40 M
x86_64
       docker
noarch
       extras
x86_64
       docker
x86_64
       docker
Transaction Summary
===============================================================================
===============================================================================
======================
Install  1 Package (+3 Dependent packages)
Total download size: 87 M
Installed size: 363 M
Background downloading packages, then exiting: (1/4): container-selinux-2.107-3.el7.noarch.rpm
39 kB 00:00:00
(2/4): containerd.io-1.2.13-3.1.el7.x86_64.rpm
23 MB 00:00:00
(3/4): docker-ce-19.03.8-3.el7.x86_64.rpm
25 MB 00:00:00
(4/4): docker-ce-cli-19.03.8-3.el7.x86_64.rpm
|
|
|
- 48 -
Repository

Linux 离线安装
 |
40 MB 00:00:00 ------------------------------------------------------------------------------- ------------------------------------------------------------------------------- ----------------------
Total
    87 MB  00:00:00
  exiting because "Download Only" specified
复制到目标服务器之后进入文件夹安装(C-N)
yum install *.rpm
锁定软件版本(C-N) 下载锁定版本软件
可参考下文的网络源搭建
sudo yum install yum-plugin-versionlock
锁定软件版本
  sudo yum versionlock add docker
查看锁定列表
  sudo yum versionlock list
Loaded plugins: fastestmirror, versionlock 3:docker-ce-18.09.9-3.el7.*
versionlock list done
锁定后无法再更新
118 MB/s |
      sudo yum install docker-ce
Loaded plugins: fastestmirror, versionlock
Loading mirror speeds from cached hostfile
Excluding 1 update due to versionlock (use "yum versionlock status" to show it) Package 3:docker-ce-18.09.9-3.el7.x86_64 already installed and latest version Nothing to do
解锁指定软件
- 49 -

Linux 离线安装
 sudo yum versionlock delete docker-ce
Loaded plugins: fastestmirror, versionlock
Deleting versionlock for: 3:docker-ce-18.09.9-3.el7.* versionlock deleted: 1
解锁所有软件
  sudo yum versionlock delete all
YUM 本地源服务器搭建安装Docker 挂载 ISO 镜像搭建本地 File 源(AB)
# 删除其他网络源
rm -f /etc/yum.repo.d/* # 挂载光盘或者iso镜像 mount /dev/cdrom /mnt
# 添加本地源
cat >/etc/yum.repos.d/local_files.repo<< EOF [Local_Files]
name=Local_Files
baseurl=file:///mnt
enable=1
gpgcheck=0 gpgkey=file:///mnt/RPM-GPG-KEY-CentOS-7
EOF
# 测试刚才的本地源,安装createrepo软件 yum clean all
yum install createrepo -y
根据本地文件搭建BASE网络源(B)
# 安装apache 服务器
yum install httpd -y
# 挂载光盘
mount /dev/cdrom /mnt
# 新建centos目录
mkdir /var/www/html/base
# 复制光盘内的文件到刚才新建的目录
cp -R /mnt/Packages/* /var/www/html/base/

Linux 离线安装
   createrepo  /var/www/html/centos/
  systemctl enable httpd
  systemctl start httpd
下载Docker-CE 镜像仓库(A) 在有网络的服务器上下载Docker-ce镜像
# 下载清华的镜像源文件
wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/cento s/docker-ce.repo
sudo sed -i 's+download.docker.com+mirrors.tuna.tsinghua.edu.cn/docker-ce+' /et c/yum.repos.d/docker-ce.repo
# 新建 docker-ce目录
mkdir /tmp/docker-ce/
# 把镜像源同步到镜像文件中
reposync -r docker-ce-stable -p /tmp/docker-ce/
创建仓库索引(B)
把下载的 docker-ce 文件夹复制到离线的服务器
# 把docker-ce 文件夹复制到/var/www/html/docker-ce # 重建索引
createrepo /var/www/html/docker-ce/
YUM 客户端设置(C...N)
rm -f /etc/yum.repo.d/*
cat >/etc/yum.repos.d/local_files.repo<< EOF [local_base]
name=local_base
# 改成B服务器地址
baseurl=http://x.x.x.x/base
enable=1
gpgcheck=0
proxy=_none_
[docker_ce]
name=docker_ce
# 改成B服务器地址
baseurl=http://x.x.x.x/base
enable=1
gpgcheck=0
proxy=_none_
EOF
- 51 -

Linux 离线安装
 Docker 安装(C...N)
sudo yum makecache fast
sudo yum install docker-ce docker-ce-cli containerd.io sudo systemctl enable docker
- 52 -
```

### macOS 安装

```bash
Docker 系统要求
# Docker Desktop for Mac 要求系统最低为 macOS Catalina 10.13。

安装
# 使用 Homebrew 安装
$ brew cask install docker

# 手动下载安装
# 如果需要手动下载，请点击以下链接下载 Stable 或 Edge 版本的 Docker Desktop for Mac。
# 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖 拽到 Application 文件夹即可(其间需要输入用户密码)。


# 启动终端后，通过命令可以检查安装后的 Docker 版本。
$ docker --version
Docker version 19.03.8, build afacb8b

$ docker-compose --version
docker-compose version 1.25.5, build 8a1c60f6


# 如果 docker version 、 docker info 都正常的话，可以尝试运行一个 Nginx 服务器:
$ docker run -d -p 80:80 --name webserver nginx

# 服务运行后，可以访问 http://localhost，如果看到了 "Welcome to nginx!"，就说明 Docker Desktop for Mac 安装成功了。

# 要停止 Nginx 服务器并删除执行下面的命令:
$ docker stop webserver
$ docker rm webserver

```


### Windows 10 安装 Docker


```
系统要求
Docker Desktop for Windows 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V(若版本为 v1903 及以上则无需开启 Hyper-V)，或者 64 位版本的 Windows 10 Home v1903 及以上版本。
安装
手动下载安装
点击以下链接下载 Stable 或 Edge 版本的 Docker Desktop for Windows。 下载好之后双击 Docker Desktop Installer.exe 开始安装。
使用 winget 安装
# stable
$ winget install Docker.DockerDesktop
# edge
$ winget install Docker.DockerDesktopEdge
运行
在 Windows 搜索栏输入 Docker 点击 Docker Desktop 开始运行。

Windows 10
 Docker 启动之后会在 Windows 任务栏出现鲸鱼图标。
等待片刻，点击 Got it 开始使用 Docker。
- 59 -

Windows 10
 镜像加速
如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。 参考链接
官方文档
Docker Desktop WSL 2 backend
- 60 -

Windows 10
WSL 2 Support is coming to Windows 10 Versions 1903 and 1909
- 61 -

镜像加速器
镜像加速器
镜像加速器
国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速 器服务，例如:
阿里云加速器(点击管理控制台 -> 登录账号(淘宝账号) -> 右侧镜像中心 -> 镜像加速器 -> 复制地址) 网易云加速器 https://hub-mirror.c.163.com
百度云加速器 https://mirror.baidubce.com
由于镜像服务可能出现宕机，建议同时配置多个镜像。各个镜像站测试结果请到 docker-practice/docker- registry-cn-mirror-test 查看。
国内各大云服务商(腾讯云、阿里云、百度云)均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云 平台选择对应的镜像加速服务，具体请参考本页最后一小节。
本节我们以 网易云 镜像服务 https://hub-mirror.c.163.com 为例进行介绍。 Ubuntu 16.04+、Debian 8+、CentOS 7+
目前主流 Linux 发行版均已使用 systemd 进行服务管理，这里介绍如何在使用 systemd 的 Linux 发行版中配置 镜像加速器。
请首先执行以下命令，查看是否在 docker.service 文件中配置过镜像地址。
$ systemctl cat docker | grep '\-\-registry\-mirror'
如果该命令有输出，那么请执行 $ systemctl cat docker 查看 ExecStart= 出现的位置，修改对 应的文件内容去掉 --registry-mirror 参数及其值，并按接下来的步骤进行配置。 如果以上命令没有任何输出，那么就可以在 /etc/docker/daemon.json 中写入如下内容(如果文件不存 在请新建该文件):
{
"registry-mirrors": [
"https://hub-mirror.c.163.com",
"https://mirror.baidubce.com" ]
}
- 62 -

镜像加速器
注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。
之后重新启动服务。
$ sudo systemctl daemon-reload $ sudo systemctl restart docker
Windows 10
对于使用 Windows 10 的用户，在任务栏托盘 Docker 图标内右键菜单选择 Settings ，打开配置窗口 后在左侧导航菜单选择 Docker Engine ，在右侧像下边一样编辑 json 文件，之后点击
Apply & Restart 保存后 Docker 就会重启并应用配置的镜像地址了。 {
"registry-mirrors": [ "https://hub-mirror.c.163.com", "https://mirror.baidubce.com"
] }
macOS
对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 ->
         Perferences
择 Docker Engine ，在右侧像下边一样编辑 json 文件。修改完成之后，点击 Apply & Restart 按
，在左侧导航菜单选
  钮，Docker 就会重启并应用配置的镜像地址了。
{
"registry-mirrors": [
"https://hub-mirror.c.163.com",
"https://mirror.baidubce.com" ]
}
检查加速器是否生效
执行 $ docker info ，如果从结果中看到了如下内容，说明配置成功。
Registry Mirrors: https://hub-mirror.c.163.com
- 63 -

镜像加速器
可以登录 阿里云 容器镜像服务镜像中心 -> 镜像搜索 查找。 例如 k8s.gcr.io/coredns:1.6.7 镜像可以用
registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.7 代替。 一般情况下有如下对应关系:
# $ docker pull k8s.gcr.io/xxx
$ docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/xxx
不再提供服务的镜像 某些镜像不再提供服务，添加无用的镜像加速器，会拖慢镜像拉取速度，你可以从镜像配置列表中删除它们。
https://dockerhub.azk8s.cn已转为私有 https://reg-mirror.qiniu.com https://registry.docker-cn.com
建议 watch(页面右上角)镜像测试 这个 GitHub 仓库，我们会在此更新各个镜像地址的状态。 云服务商
某些云服务商提供了 仅供内部 访问的镜像服务，当您的 Docker 运行在云平台时可以选择它们。
Azure 中国镜像 https://dockerhub.azk8s.cn 腾讯云 https://mirror.ccs.tencentyun.com
- 64 -

开启实验特性
开启实验特性
开启实验特性
一些 docker 命令或功能仅当 实验特性 开启时才能使用，请按照以下方法进行设置。 开启 Docker CLI 的实验特性
编辑 ~/.docker/config.json 文件，新增如下条目 {
    "experimental": "enabled"
  }
或者通过设置环境变量的方式: Linux/macOS
$ export DOCKER_CLI_EXPERIMENTAL=enabled
Windows
# 临时生效
$ set $env:DOCKER_CLI_EXPERIMENTAL="enabled"
# 永久生效
$ [environment]::SetEnvironmentvariable("DOCKER_CLI_EXPERIMENTAL","enabled","Us er")
开启 Dockerd 的实验特性
编辑 /etc/docker/daemon.json ，新增如下条目
  {
    "experimental": true
}
```


---

## Docker 镜像
- 镜像是 Docker 的三大组件之一。
- Docker 运行容器前需要本地存在对应的镜像
- 如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。

---

### 获取镜像 `docker pull ubuntu:18.04`
- Docker Hub 上有大量的高质量的镜像可以用，
- 获取这些镜像。 从 Docker 镜像仓库获取镜像的命令是 `docker pull` 。

```bash
# 其命令格式为:
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]

# 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。
- Docker 镜像仓库地址: 一般是 <域名/IP>[:端口号] 。默认地址是 Docker Hub(docker.io)。
- 仓库名: 两段式名称，即 <用户名>/<软件名> 。
- 对于 Docker Hub，如果 不给出用户名，则默认为 library 官方镜像。


# 比如:
$ docker pull ubuntu:18.04
18.04: Pulling from library/ubuntu
bf5d46315322: Pull complete
9f13e0ac480c: Pull complete
e8988b5b3097: Pull complete
40af181810e7: Pull complete
e6f7c7e5c03e: Pull complete
Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe Status: Downloaded newer image for ubuntu:18.04

$ docker pull kalilinux/kali-rolling


# 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。
# 镜像名称是 ubuntu:18.04 ，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。

# 从下载过程中可以分层存储，镜像是由多层存储所构成。
# 下载也是一层层的去下载， 并非单一文件。
# 下载过程中给出了每一层的 ID 的前 12 位。
# 并且下载结束后，给出该镜像完整的 sha256 的 摘要，以确保下载一致性。
```

---

### 运行 `docker run -it --rm ubuntu:18.04 bash`
有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。

```bash
# 以上面的 ubuntu:18.04 为例，启动里面的 bash 并且进行交互式操作:
$ docker run -it --rm ubuntu:18.04 bash
root@e7009c6ce357:/# cat /etc/os-release NAME="Ubuntu"
VERSION="18.04.1 LTS (Bionic Beaver)" ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.1 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/" BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/" PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-pol icy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic


# docker run: 运行容器的命令
# -i :交互式操作
# -t 终端。进入 bash 执 行一些命令并查看返回结果，因此我们需要交互式终端。
# --rm: 容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。
# ubuntu:18.04 :这是指用 ubuntu:18.04 镜像为基础来启动容器。
# bash: 放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash 。
# 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。
# 通过 exit 退出了这个容器。
```

---


### 列出镜像

```bash
# 列出已经下载下来的镜像
$ docker image ls
# 仓库名              标签、               镜像 ID、           创建时间              所占用的空间
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        5 days ago          183 MB
nginx                latest              05a60462f8ba        5 days ago          181 MB
mongo                3.2                 fe9198c04d62        5 days ago          342 MB
<none>               <none>              00285df0df87        5 days ago          342 MB  # 虚悬镜像 dangling image
ubuntu               18.04               f753707788c5        4 weeks ago         127 MB
ubuntu               latest              f753707788c5        4 weeks ago         127 MB

# 镜像 ID 则是镜像的唯一标识
# 一个镜像可以对应多个 标签。
```

#### 镜像体积

```bash
# 镜像体积所占用空间和在 Docker Hub 上看到的镜像大小不同。
# - ubuntu:18.04 镜像大小，在这里是 127 MB ，
# - 但是在 Docker Hub 显示的却是 50 MB 。
# - 这是因为 Docker Hub 中显示的体积是压缩后的体积。
# - 在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。
# - 而 docker image ls 显示的是镜像下载到本地后，展开的大小(展开后的各层所占空间的总和)，因为镜像到本地后，查看空间的时候，更关心的是本地磁 盘空间占用的大小。

# docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。
# - 由 于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥 有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要 比这个列表镜像大小的总和要小的多。

# 便捷的查看镜像、容器、数据卷所占用的空间。
$ docker system df
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              24                  0                   1.992GB             1.992GB (100%)
Containers          1                   0                   62.82MB             62.82MB (100%)
Local Volumes       9                   0                   652.2MB             652.2MB (100%)
Build Cache                                                 0B                  0B
```


#### 虚悬镜像


```bash
# 上面的镜像列表中，可以看到一个特殊的镜像，既没有仓库名，也没有标签，均为 <none> 。:
# <none>               <none>              00285df0df87        5 days ago     342 MB
# docker pull
# 镜像 mongo:3.2, 随着新版本后，重新 docker pull mongo:3.2 时， mongo:3.2 这个镜像名被转移到了新下载的镜像身上
# 旧的镜像上的这个名称则被取消，从而成为了 <none> 。
# docker build
# 由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。
# 这类无标签镜像也被称为 虚悬镜像(dangling image) ，

# 专门显示 这类镜像:
$ docker image ls -f dangling=true
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<none>              <none>              00285df0df87        5 days ago          342 MB

# 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的:
$ docker image prune
```


#### 中间层镜像


```bash
# 为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。
# 所以在使用一段时间后，可能会看到一些依赖 的中间层镜像。
# 默认的 docker image ls 只会显示顶层镜像

# 显示包括中间层镜像在内的列出镜像所有镜像的话，加 -a 参数。
$ docker image ls -a
# 这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所 依赖的镜像。
# 这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。
# 实际上，这些镜像也没必 要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而 多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删 除。
```


#### 列出部分镜像


```bash
# 不加任何参数的情况下， docker image ls 会列出所有顶层镜像，
# 只希望列出部分镜像。 docker image ls 有好几个参数可以帮助做到这个事情。

# 根据仓库名列出镜像
$ docker image ls ubuntu
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.04               f753707788c5        4 weeks ago         127 MB
ubuntu              latest              f753707788c5        4 weeks ago         127 MB


# 列出特定的某个镜像，也就是说指定仓库名和标签
$ docker image ls ubuntu:18.04
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.04               f753707788c5        4 weeks ago         127 MB


# 除此以外， docker image ls 还支持强大的过滤器参数 --filter ，或者简写 -f 。
# 使用过滤器来列出虚悬镜像
$ docker image ls -f dangling=true
# 希望看到在 mongo:3.2 之后建 立的镜像，可以用下面的命令:
$ docker image ls -f since=mongo:3.2
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
redis               latest              5f515359c7f8        5 days ago          183 MB
nginx               latest              05a60462f8ba        5 days ago          181 MB
# 想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。
$ docker image ls -f before=mongo:3.2
# 此外，如果镜像构建时，定义了 LABEL ，还可以通过 LABEL 来过滤。
$ docker image ls -f label=com.example.version=0.1
```

#### 以特定格式显示


```bash
# 默认情况下， docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。
# 比 如，刚才删除虚悬镜像的时候，需要利用 docker image ls 把虚悬镜像的 ID 列来，然后交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。
$ docker image ls -q
5f515359c7f8
05a60462f8ba
fe9198c04d62
00285df0df87
f753707788c5
f753707788c5
1e0c3dd64ccd

# --filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这 组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命 令中看到这类搭配以完成很强大的功能。


# 只是对表格的结构不满意，希望自己组织列; 或者不希望有标题, 这就用到了 Go 的模板语法。

# 直接列出镜像结果，并且只包含镜像ID和仓库名:
$ docker image ls --format "{{.ID}}: {{.Repository}}"
5f515359c7f8: redis
05a60462f8ba: nginx
fe9198c04d62: mongo
00285df0df87: <none>
f753707788c5: ubuntu
f753707788c5: ubuntu
1e0c3dd64ccd: ubuntu


# 或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列:
$ docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"
IMAGE ID            REPOSITORY          TAG
5f515359c7f8        redis               latest
05a60462f8ba        nginx               latest
fe9198c04d62        mongo               3.2
00285df0df87        <none>              <none>
f753707788c5        ubuntu              18.04
f753707788c5        ubuntu              latest
```

---


### 删除本地镜像 `$ docker image rm centos:latest`


```bash
# 删除本地的镜
$ docker image rm [选项] <镜像1> [<镜像2> ...]

# 用 ID、镜像名、摘要删除镜像
# 其中， <镜像> 可以是 镜像短ID 、 镜像长ID 、 镜像名 或者 镜像摘要 。
$ docker image ls
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB
redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB
docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB
nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB


# 长 ID 人工输入就太累, 用 短 ID 来删除镜像。
# docker image ls 默认列出的就已经是短 ID 了，一 般取前3个字符以上，只要足够区分于别的镜像就可以了。
$ docker image rm 501

# 也可以用 镜像名 ，<仓库名>:<标签>
$ docker image rm centos:latest

# 更精确的是使用 镜像摘要 删除镜像。
$ docker image ls --digests
REPOSITORY   TAG       DIGEST                                                                    IMAGE ID            CREATED             SIZE
node         slim      sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB

$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
```



#### Untagged 和 Deleted

删除行为分为两类，一类是 `Untagged` ，另一类 是 `Deleted` 。
- 镜像的唯一标识是其 `ID` 和 `摘要`
- 一个镜像可以有多个标签。
- 因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。
  - 将满足我 们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。
  - 因为一个镜像可以对应多个标签，当还有别的标签指向了这个镜像，那么 Delete 行为 就不会发生。
- 所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。
- 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。
- 镜像是多层存储结 构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。
- 镜像的多层结构让镜像复用变得非常容易， 因此很有可能某个其它镜像正依赖于当前镜像的某一层。
- 这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。
- 这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个 镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不 一样的原因。
- 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在(即使容器没有运 行)，那么同样不可以删除这个镜像。
- 容器是以镜像为基础，再加一层容器存储层，组成这样的多层 存储结构去运行的。
- 因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。
- 如果这些容器是不需要 的，应该先将它们删除，然后再来删除镜像。

```bash
# 用 docker image ls 命令来配合像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用docker image rm ，这样可以成批的删除希望删除的镜像。
# 删除所有仓库名为 redis 的镜像:
$ docker image rm $(docker image ls -q redis)
# 或者删除所有在 mongo:3.2 之前的镜像:
$ docker image rm $(docker image ls -q -f before=mongo:3.2)
```

## commit 理解镜像构成

```bash
注意:如果您是初学者，您可以暂时跳过后面的内容，直接学习 容器 一节。
```


---


## 操作 Docker 容器

- 容器是独立运行的`一个或一组应用`，以及它们的`运行态环境`。
- 对应的，虚拟机可以理解为`模拟运行的一整套操作系统`(提供了运行态环境和其他系统环境)和`跑在上面的应用`。


### 启动容器 `docker run ubuntu:18.04`
启动容器有两种方式
- 基于镜像新建一个容器并启动，
- 将在终止状态( stopped )的容器重新启动。


当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括:
- 检查本地是否存在指定的镜像，不存在就从公有仓库下载
- 利用镜像创建并启动一个容器
- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
- 从地址池配置一个 ip 地址给容器
- 执行用户指定的应用程序
- 执行完毕后容器被终止


> 因为 Docker 的容器实在太轻量级了，很多时候都是随时删除和新创建容器。

```bash
# 新建并启动
# 输出一个 “Hello World”，之后终止容器。
$ docker run ubuntu:18.04 /bin/echo 'Hello world'
Hello world
# 这跟在本地直接执行 /bin/echo 'hello world' 几乎感觉不出任何区别。


# 启动一个 bash 终端，允许用户进行交互。
$ docker run -t -i ubuntu:18.04 /bin/bash
root@af8bae53bdd3:/#
root@af8bae53bdd3:/# ls
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
# -t 选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上
# -i 则让容器的标准输入保持打开。
# 在交互模式下，用户可以通过所创建的终端来输入命令
```


---

### 启动已终止容器 `docker container start`

将一个已经终止的容器启动运行。
- 容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。
- 除此之外，并没有其它的资源。
- 可 以在伪终端中利用 ps 或 top 来查看进程信息。


```bash
root@ba267838cc1b:/# ps
  PID TTY          TIME CMD
    1 ?        00:00:00 bash
   11 ?        00:00:00 ps


可见，容器中仅运行了指定的 bash 应用。
这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚 拟化。
```

---

### Daemon 运行 `docker run -d ubuntu:18.04 /bin/bash whoami`


```bash
# 1. 后台运行
# 让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。
# 通过添 加 -d 参数来实现。

# 不使用 -d 参数运行容器。
# 容器会把输出的结果 (STDOUT) 打印到宿主机上面
$ docker run ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"
hello world
hello world
hello world
hello world

# 使用了 -d 参数运行容器。
# 此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面
$ docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
# 输出结果可以用 docker logs 查 看
$ docker container logs [container ID or NAMES]
hello world
hello world
hello world
. . .

# 注: 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。
# 使用 -d 参数启动后会返回一个唯一的 id，
# 可以通过 docker container ls 命令来查看容器信息。
$ docker container ls
CONTAINER ID  IMAGE         COMMAND                  CREATED        STATUS             PORTS NAMES
77b2dc01fe0f  ubuntu:18.04  /bin/sh -c 'while tr..'  2 minutes ago  Up 1 minute        agitated_wright
```

---

### 终止容器 `docker container stop`

- 当 Docker 容器中指定的应用终结时，容器也自动终止。
- 例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的 容器立刻终止。

```bash
# 终止状态的容器: docker container ls -a
docker container ls -a
CONTAINER ID   IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES
ba267838cc1b   ubuntu:18.04             "/bin/bash"            30 minutes ago      Exited (0) About a minute ago                       trusting_newton
98e5efa7d997   training/webapp:latest   "python app.py"        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike


# 处于终止状态的容器，通过 docker container start 命令来重新启动。
# docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。
```

---

### 进入容器 进入容器 `docker run -dit ubuntu`

使用 `-d` 参数，容器启动后会进入后台。
- 某些时候需要进入容器进行操作，包括使用 `docker attach` 命令或 `docker exec` 命令，
- 推荐使用 docker exec 命令

> 只用 -i 参数时，由于没有分配伪终端，界面没有熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。
> -i -t 参数一起使用时，则可以看到Linux 命令提示符。


```bash
# docker attach 命令
$ docker run -dit ubuntu
243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550

$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia

$ docker attach 243c
root@243c32535da7:/#
# 注意: 如果从这个 stdin 中 exit，会导致容器的停止。



# exec 命令
$ docker run -dit ubuntu
69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6

$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles

$ docker exec -i 69d1 bash
ls
bin
boot
dev
...

$ docker exec -it 69d1 bash
root@69d137adef7a:/#

# 如果从这个 stdin 中 exit，不会导致容器的停止。
# 这就是为什么推荐大家使用docker exec
```


---

### 导出容器 `$ docker export 7691a814370e > ubuntu.tar`

```bash
# 导出容器 docker export
$ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test

$ docker export 7691a814370e > ubuntu.tar
```

---


### 导入容器 `$ cat ubuntu.tar | docker import - test/ubuntu:v1.0`

```bash
导入 docker import

# 从容器快照文件中再导入为镜像
$ cat ubuntu.tar | docker import - test/ubuntu:v1.0

$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB


# 通过指定 URL 或者某个目录来导入
$ docker import http://example.com/exampleimage.tgz example/imagerepo



# docker load 导入 镜像存储文件 到本地镜像库，
# docker import 导入一个 容器快照 到本地镜像库。
# 两者的区别在于
# 容器快照文件将丢弃所有的历史记录和元数据信息(即仅 保存容器当时的快照状态)，
# 而镜像存储文件将保存完整记录，体积也要大。
# 此外，从容器快照文件导入时可以 重新指定标签等元数据信息。
```


---


### 删除容器 `docker container rm ubuntu`



```bash
# 删除一个处于终止状态的容器
$ docker container rm trusting_newton
trusting_newton



# 如果要删除一个运行中的容器，
# 添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。



# 清理所有处于终止状态的容器
# 用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多，用下面的命令可以清理掉所有处于终止状态的容器。
$ docker container prune
```


---

## 访问仓库


`仓库( Repository )`是集中存放镜像的地方。
- 一个容易混淆的概念是`注册服务器( Registry )`。
- 实际上 Registry 是管理 Repository 的具体服务器
- 每个 Registry 上可以有多个Repository，而每个Repository下面有多个镜像。
- 仓库可以被认为是一个具体的项目或目录。
- 例 如对于仓库地址 docker.io/ubuntu 来说， docker.io 是注册服务器地址， ubuntu 是仓库名。
- 大部分时候，并不需要严格区分这两者的概念。

### Docker Hub
- Docker 官方维护一个公共仓库 Docker Hub，其中已经包括了数量超过 2,650,000 的镜像。
- 大部分需求 都可以通过在 Docker Hub 中直接下载镜像来实现。
  - 注册 https://hub.docker.com
  - 执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。
  - 通过 docker logout 退出登录。
  - 通过 docker search 命令来查找官方仓库中的镜像，
    - `$ docker search centos`
    - ![Screen Shot 2020-11-27 at 23.47.30](https://i.imgur.com/tsm4uv5.png)
  - 利用 docker pull 命令来将它下载到 本地。
    - `$ docker pull centos`
    - ![Screen Shot 2020-11-27 at 23.46.59](https://i.imgur.com/T5Dlbur.png)
  - 通过 docker push 将自己的镜像推送到 Docker Hub。
    - `$ docker push username/ubuntu:18.04`
    - ![Screen Shot 2020-11-27 at 23.50.11](https://i.imgur.com/6wlM31P.png)


### 自动构建 Automated Builds

对于需要经常升级镜像内程序来说十分方便。
- 有时候，构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。
- 而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站(支持 GitHub 或 BitBucket)上的项目，一旦项 目发生新的提交 (commit)或者创建了新的标签(tag)，Docker Hub 会自动构建镜像并推送到 Docker Hub 中。

```bash
# 要配置自动构建，包括如下的步骤:

登录 Docker Hub;
在 Docker Hub 点击右上角头像，在账号设置(Account Settings)中关联(Linked Accounts)目标网 站;
在 Docker Hub 中新建或选择已有的仓库，在 Builds 选项卡中选择 Configure Automated Builds ;
选取一个目标网站中的项目(需要含 Dockerfile )和分支;
指定 Dockerfile 的位置，并保存。
之后，可以在 Docker Hub 的仓库页面的 Timeline 选项卡中查看每次构建的状态。
```



---


### 私有仓库

用户可以创建一个本地仓库供私人使用。
- `docker-registry` 是官方提供的工具，用于构建私有的镜像仓库。

```bash
# 安装运行 docker-registry 容器运行
# 通过获取官方 registry 镜像来运行。
$ docker run -d -p 5000:5000 --restart=always --name registry registry
# 这将使用官方的 registry 镜像来启动私有仓库。


# 默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。
# 通过 -v 参数来将镜像文件存放在本地的指定路径。
# 例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。
$ docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry



# 在私有仓库上传、搜索、下载镜像
# 使用 docker tag 来标记一个镜像，然后推送它到仓库。
# 例如私有仓库地址为 127.0.0.1:5000 。

# 在本机查看已有的镜像。
$ docker image ls
REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB

# 使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest 。
# 格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG] 。
$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest
$ docker image ls
REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB
127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB



# 用 curl 查看仓库中的镜像。
$ curl 127.0.0.1:5000/v2/_catalog
{"repositories":["ubuntu"]}
# 这里可以看到 {"repositories":["ubuntu"]} ，表明镜像已经被成功上传了。


# 先删除已有镜像，再尝试从私有仓库中下载这个镜像。
$ docker image rm 127.0.0.1:5000/ubuntu:latest

$ docker pull 127.0.0.1:5000/ubuntu:latest
Pulling repository 127.0.0.1:5000/ubuntu:latest ba5877dc9bec: Download complete
511136ea3c5a: Download complete
9bad880da3d2: Download complete
25f11f5fb0cb: Download complete
ebc34468f71d: Download complete
2318d26665ef: Download complete

$ docker image ls
REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB


注意事项
如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。
就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推 送镜像。
这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制， 或者查看下一节配置能够通过 HTTPS 访问的私有仓库。
```


---


### Ubuntu 16.04+, Debian 8+, centos 7



```bash
# 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容(如果文件不存在请新 建该文件)
{
  "registry-mirror": [
    "https://registry.docker-cn.com"
  ],
  "insecure-registries": [
    "192.168.199.100:5000"
  ]
}


注意:该文件必须符合 json 规范，否则 Docker 将不能启动。
```

---

### 其他

```
对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 辑 ，增加和上边一样的字符串即可。
```


---



## 数据管理

![types-of-mounts](https://i.imgur.com/7WJZSlC.png)

在容器中管理数据主要有两种方式:
- 数据卷(Volumes)
- 挂载主机目录 (Bind mounts)

---

### 数据卷(Volumes)

- 一个可供一个或多个容器使用的特殊目录
- 它绕过 UFS，可以提供很多有用的特性:
- 可以在容器之间共享和重用
- 对 数据卷 的修改会立马生效
- 对 数据卷 的更新，不会影响镜像
- 数据卷 默认会一直存在，即使容器被删除
注意: 数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中(仅数据卷为空时会复制)。


```bash
# 创建一个数据卷
$ docker volume create my-vol

# 查看所有的 数据卷
$ docker volume ls
DRIVER VOLUME NAME
local my-vol
```

---



#### 删除数据卷 `docker volume rm my-vol`


数据卷 是被设计用来持久化数据的
- 它的生命周期独立于容器，Docker 不会在容器被删除后自动删除
- 也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷 。
- 删除数据卷 `docker volume rm my-vol`
- 如果需要在 删除容器的同时移除数据卷 `docker rm -v`
- 无主的数据卷会占据很多空间，要清理请使用以下命令 `docker volume prune`


---


#### 启动一个挂载数据卷的容器

用 docker run 命令的时候
- 使用 `--mount` 标记来将 数据卷 挂载到容器里。
- 在一次 docker run 中可以挂载多个 数据卷 。

```bash
# 创建一个名为 web 的容器，
# 并加载一个 数据卷 到容器的 /usr/share/nginx/html 目录。
$ docker run -d -P --name web \
    # -v my-vol:/webapp \
    --mount source=my-vol, target=/webapp \
    training/webapp \
    python app.py
```


---

### 启动一个挂载主机目录的容器

- 挂载一个主机目录作为数据卷
- 使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。


```bash
$ docker run -d -P --name web \
    # -v /src/webapp:/opt/webapp \
    --mount type=bind, source=/src/webapp, target=/opt/webapp \
    training/webapp \
    python app.py

# 上面的命令加载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html 目录。
# 这个功能在进行 测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。
# 本地目录的路径必 须是绝对路径，
# 以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，
# 现在使用--mount 参数时如果本地目录不存在，Docker 会报错。

# Docker挂载主机目录的默认权限是 读写 ，用户也可以通过增加 readonly 指定为 只读 。
$ docker run -d -P \
    --name web \
    # -v /src/webapp:/opt/webapp:ro \
    --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \
    training/webapp \
    python app.py



# 加了 readonly 之后，就挂载为 只读 了。
# 如果你在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误
/opt/webapp # touch new.txt
touch: new.txt: Read-only file system
```

---


#### 查看数据卷的具体信息 `$ docker inspect web`

```bash
# 在主机里使用以下命令可以查看 web 容器的信息
$ docker inspect web
# 挂载主机目录 的配置信息在 "Mounts" Key 下面
"Mounts": [
    {
        "Type": "bind",
        "Source": "/src/webapp",
        "Destination": "/opt/webapp",
        "Mode": "",
        "RW": true,
        "Propagation": "rprivate"
    }
],
```


---


#### 挂载一个本地主机文件作为数据卷

```bash
# 从主机挂载单个文件到容器中
$ docker run --rm -it \
   # -v $HOME/.bash_history:/root/.bash_history \
   --mount type=bind, source=$HOME/.bash_history, target=/root/.bash_history \
   ubuntu:18.04 bash


$ docker run --rm -it --mount type=bind, source=$HOME/.bash_history, target=/root/.bash_history ubuntu:18.04 bash

root@2affd44b4667:/# history
1  ls
2  diskutil list

# 这样就可以记录在容器输入过的命令了。
```

---


## 网络

> Docker 中的网络功能介绍 Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。


---

### 外部访问容器

- 容器中可以运行一些网络应用，要让外部也可以访问这些应用，通过 -P 或 -p 参数来指定端口映 射。
- -P: Docker 会随机映射一个端口到内部容器开放的网络端口。
- -p: 可以指定要映射的端口，
  - 并且，在一个指定端口上只可以绑定一个容器。
  - 支持的格式有
  - `ip:hostPort:containerPort`
  - `ip::containerPort`
  - `hostPort:containerPort`


```bash

# 使用 docker container ls 可以看到，本地主机的 32768 被映射到了容器的 80 端口。
# 此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。
$ docker run -d -P training/webapp python app.py

$ docker container ls -l
CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES
bc533791f3f5  training/webapp:latest  python app.py 5 seconds ago  Up 2 seconds  0.0.0.0:49155->5000/tcp  nostalgic_morse



# 可以通过 docker logs 命令来查看应用的信息。
$ docker logs -f nostalgic_morse
* Running on http://0.0.0.0:5000/
10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -
10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1" 404 -
```




> 注意：
> 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）

-p 标记可以多次使用来绑定多个端口

例如

```bash
$ docker run -d -p 5000:5000 -p 3000:80 \
    training/webapp \
    python app.py
```


---

#### 映射所有接口地址 `$ docker run -d -p 5000:5000 training/webapp python app.py`

```bash
# 使用 hostPort:containerPort 格式本地的 80 端口映射到容器的 80 端口:
$ docker run -d -p 5000:5000 training/webapp python app.py
此时默认会绑定本地所有接口上的所有地址。
```



---

#### 映射到指定地址的指定端口 `$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py`

```bash
# 可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1
$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
```


---

#### 映射到指定地址的任意端口

```bash
# 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。
$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py


# 还可以使用 udp 标记来指定 udp 端口
$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
```

---


#### 查看映射端口配置 `$ docker port container_name 5000`

```bash
# 使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址
$ docker port container_name 5000
127.0.0.1:49155.
```


---

### 容器互联

容器互联
- 使用 --link 参数来使容器互联。
- 将容器加入自定义的 Docker 网络来连接多个容器



---

### 新建网络 `$ docker network create -d bridge my-net`

```bash
# 创建一个新的 Docker 网络。
$ docker network create -d bridge my-net
# -d 参数指定 Docker 网络类型: bridge, overlay(用于 Swarm mode)
```

---


### 连接容器

```bash
# 运行一个容器并连接到新建的 my-net 网络
$ docker run -it --rm --name busybox1 --network my-net busybox sh
# 打开新的终端，再运行一个容器并加入到 my-net 网络
$ docker run -it --rm --name busybox2 --network my-net busybox sh
# 再打开一个新的终端查看容器信息
$ docker container ls

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
b47060aca56b        busybox             "sh"                11 minutes ago      Up 11 minutes                           busybox2
8720575823ec        busybox             "sh"                16 minutes ago      Up 16 minutes                           busybox1


# 通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。
# 在 busybox1 容器输入以下命令
/ # ping busybox2
PING busybox2 (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms
# 用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。


# 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。
/ # ping busybox1
PING busybox1 (172.19.0.2): 56 data bytes
64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms
64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms


# 这样， busybox1 容器和 busybox2 容器建立了互联关系。


Docker Compose
如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。
```


---


### 配置 DNS

自定义配置容器的主机名和 DNS
- Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。


```bash
# 在容器中使用 mount 命令可以看到挂载信息：
# 这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。
$ mount
/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...
/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...
tmpfs on /etc/resolv.conf type tmpfs ...



# 也可以在 /etc/docker/daemon.json 文件中增加以下内容来设置。配置全部容器的 DNS.
# 这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}


# 使用以下命令来证明其已经生效。
$ docker run -it --rm ubuntu:18.04 cat etc/resolv.conf
nameserver 114.114.114.114
nameserver 8.8.8.8



# 手动指定容器的配置，在使用 docker run 命令启动容器时加入如下参数:
# -h HOSTNAME, --hostname=HOSTNAME
    # 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts 。
    # 但它在容器外部看不到，既不会在 docker container ls 中 显示，也不会在其他的容器的 /etc/hosts 看到。

# --dns=IP_ADDRESS
    # 添加 DNS 服务器到容器的 /etc/resolv.conf 中
    # 让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。

# --dns-search=DOMAIN
    # 设定容器的搜索域
    # 当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com

# 注意:如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 /etc/resolv.conf 来配 置容器。
```


---


## 高级网络配置





---


## Docker Compose

Docker Compose
- Docker 官方编排(Orchestration)开源项目之一
- 负责实现对 Docker 容器集群的快速编排。
- 从功能上看，跟OpenStack 中的 Heat 十分类似。
- 其代码目前在 https://github.com/docker/compose 上开源。
- Compose 定位是 「定义和运行多个 Docker 容器的应用(Defining and running multi-container Docker applications)」，其前身是开源项目 Fig。



使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。
- 然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。
- 例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。


Compose 恰好满足了这样的需求。
- 它允许用户通过一个单独的 docker-compose.yml 模板文件 (YAML 格式)来定义一组相关联的应用容器为一个项目(project)。


Compose 中有两个重要的概念:
- `服务 ( service )`: 
  - 一个应用的容器，
  - 实际上可以包括若干运行相同镜像的容器实例。
- `项目 ( project )`: 
  - 由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文 件中定义。
- 一个 project 可以由多个 service（容器）关联而成
- Compose 面向 project 进行管理。
- Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。


Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。
- 因此，只要所操 作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。


---

### 安装与卸载


`Compose` 支持 Linux、macOS、Windows 10 三大平台。

`Compose` 可以通过 Python 的包管理工具 `pip` 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。

`Docker Desktop for Mac/Windows` 自带 `docker-compose` 二进制文件，安装 Docker 之后可以直接使用。

    $ docker-compose --version
    
    docker-compose version 1.24.1, build 4667896b
    

```bash
# Linux安装。

# 二进制包
# 从 [官方 GitHub Release](https://github.com/docker/compose/releases) 处直接下载编译好的二进制文件即可。
# 例如，在 Linux 64 位系统上直接下载对应的二进制包。

$ sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
    
$ sudo chmod +x /usr/local/bin/docker-compose
    

# PIP 安装
# _注：_ `x86_64` 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 `ARM` (例如，树莓派)，再使用 `pip` 安装。
# 这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。

# 执行安装命令：
$ sudo pip install -U docker-compose
# 可以看到类似如下输出，说明安装成功。
Collecting docker-compose
Downloading docker-compose-1.24.1.tar.gz (149kB): 149kB downloaded
...
Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty sienum34 backports.ssl-match-hostname ipaddress
    

# bash 补全命令
$ curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose
    

# 卸载

# 如果是二进制包方式安装的，删除二进制文件即可。

    $ sudo rm /usr/local/bin/docker-compose
    

# 如果是通过 `pip` 安装的，则执行如下命令即可删除。

    $ sudo pip uninstall docker-compose
```




























.

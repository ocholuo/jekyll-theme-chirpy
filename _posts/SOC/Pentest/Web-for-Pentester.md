






# Web technologies
Most web applications rely on 3 components:
1. The client: a web browser in most cases.
2. The web server that will receive requests from the client. An application server can be involved to process the requests; in that case the web server will just forward the requests to the application server.
3. The storage backend to retrieve and save information, most commonly a database.

Client side technologies
- Most client side technologies: 
  - HTML, JavaScript, Flash... through their browsers (Chromium, Firefox, Internet Explorer, Safari...). 
- However, web applications' clients can also be a thick client connecting to a web service or just a script.

Server side technologies
- The server side can be divided into more sub-categories:
  - Web servers
    - Apache, lighttpd, Nginx, IIS...
  - Application servers
    - Tomcat, Jboss, Oracle Application server...
  - The programming language used: 
    - PHP, Java, Ruby, Python, ASP, C#, ... 
    - This programming language can also be used as part of a framework like Ruby-on-Rails, .Net MVC, Django.

Storage backend
- The storage backend can be located on the same server as the web server or on a different one. This can explain weird behaviour during the exploitation of some vulnerabilities.
- A few examples of backends are:
  - Simple files.
  - Relational databases
    - Mysql, Oracle, SQL Server, PostgreSQL.
  - Other databases
    - MongoDB, CouchDB.
  - Directories
    - openLDAP or Active Directory.

An application can use more than one storage backend. For example, some applications use LDAP to store users and their credentials and use Oracle to store information.

---

# The HTTP protocol
HTTP is the base of the web, it's really important to have a deep understanding of this protocol in order to perform web security testing. Knowing and understanding HTTP specificities will often allow you to find vulnerabilities and exploit them.

## A Client-server dialog
- HTTP is a dialog between one client and one server. 
- The client, the browser, sends a request to the server, and then the server responds to this request. 
- HTTP has the advantages of being a text protocol and therefore really easy to read, understand and learn for a human being. 
- By default, most web servers are available on port TCP/80. 
  - When your browser connects to a URL http://pentesterlab.com/, it d a TCP connection to the port 80 of the IP corresponding to the name pentesterlab.com.

The most common request occurs when a browser asks the server for content.
- The browser sends a request composed of the following elements:
  - An `HTTP method` that will allow the server to understand what kind of operation the browser wants to perform.
  - A `resource` that corresponds to what the client is trying to access on the server.
  - A `version` that will allow the server to know what version of HTTP the browser is talking.
  - Optionally, various headers giving more information to the server like the browser's name and version, the preferred language of the user (like in English, German, French,...), ...
  - Depending on the HTTP method used, a `request body`.

```
As an example

request to the URL http://vulnerable/index.php will correspond to the following HTTP request:

GET /index.php HTTP/1.1
Host: vulnerable
User-Agent: Mozilla Firefox

```

## Requests

## Methods

Many HTTP methods exist:
- The `GET` method: 
  - to request for content, it's the most common request sent by browsers;
- The `POST` method: 
  - POST is used to send a larger amount of data; 
  - used by most forms and also for file upload.
- The `HEAD` method: 
  - the HEAD method is very similar to the GET request, 
  - the only difference is in the response provided by the server, 
  - the response will only contain the headers and no body. 
  - `HEAD` is massively used by web spiders to check if a web page has been updated without downloading the full page content.
  - many other HTTP methods: 
    - PUT, DELETE, PATCH, TRACE, OPTIONS, CONNECT... 
    
## Parameters

When a client accesses the following page http://vulnerable/article.php?id=1&name=2, 

the following request is sent to the web server:

```html
GET /article.php?id=1&name=2 HTTP/1.1
Host: vulnerable
User-Agent: Mozilla Firefox
```

POST requests are really similar, but instead the parameters are sent in the request body. 

For example for the form:

1. This HTML code

```bash
# This HTML code

        <html>
            [...] 
        <body>
            <form action="/login.php" method="POST">
                Username: <input type="text" name="username"/> <br/>
                Password: <input type="password" name="password"/> <br/>
                <input type="submit" value="Submit">
            </form>
        </body>
        </html>


# This HTML code corresponds to the browswer login form:
# - Once the form is filled with the following values:

        username equals 'admin',
        password equals 'Password123'.
```

2. client request sent to the server:

```bash
# After it gets submitted, the following request is sent to the server:

        POST /login.php HTTP/1.1
        Host: vulnerable
        User-Agent: Mozilla Firefox
        Content-Length: 35
        username=admin&password=Password123

# NB: 

# if the method GET was used in the <form tag, 
# the values provided will be sent as part of the URL and look like:

        GET /login.php?username=admin&password=Password123 HTTP/1.1
        Host: vulnerable
        User-Agent: Mozilla Firefox

# If the form tag contains an attribute enctype="multipart/form-data", 
# the request sent will be different:

        POST /upload/example1.php HTTP/1.1
        Host: vulnerable
        Content-Length: 305
        User-Agent: Mozilla/5.0 [...] AppleWebKit
        Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryfLW6oGspQZKVxZjA
        # a different Content-type header
        ------WebKitFormBoundaryfLW6oGspQZKVxZjA
        Content-Disposition: form-data; name="image"; filename="myfile.html"
        Content-Type: text/html
        My file
        ------WebKitFormBoundaryfLW6oGspQZKVxZjA
        Content-Disposition: form-data; name="send"
        Send file
        ------WebKitFormBoundaryfLW6oGspQZKVxZjA--

We can see that there is a different `Content-type` header: `Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryfLW6oGspQZKVxZjA`. 
- The `"Webkit"` comes from a Webkit-based browser; 
- other browsers will use a long random string instead. 
- This string is repeated for every part of the multipart information. 
- The last part contains the string followed by `--`.


# When upload a file
# In the multi-part section dedicated to the file, you will see the following information:


The file name: myfile.html.
The parameter name: image.
The file content type: text/html.
The file content: My file.
It's also possible to send parameters as an array (or hash depending on the parsing performed on the server side). You can for example use: /index.php?id[1]=0 to encode an array containing the value 0.

This method of encoding is often used by frameworks to perform automatic request to object mapping. For example, the following request: user[name]=louis&user[group]=1 will be mapped to an object User with the attribute name equal to louis and the attribute group mapped to 1. This automatic mapping can sometimes be exploited using attacks named mass-assignment. By sending additional parameters, you can, if the application does not protect against it, change attributes in the receiving object. In our previous example, you could for example add user[admin]=1 to the request and see if your user gets administrator privileges.
```



.